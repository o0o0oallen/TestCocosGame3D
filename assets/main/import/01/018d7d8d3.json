[1,["aa3gnuj51BPKnojGhupeFg@73b7f","b6mOVasAtJh6i0r4PN3Fn3","aa3gnuj51BPKnojGhupeFg@ef5e1","aa3gnuj51BPKnojGhupeFg@438fe","8aWN3s9DdAuY7AH8h96X+1","5a8gG1WVFOLKgfrEqtkTLL@b47c0","e3VTytLxVCk4Waj0PHgPKJ@73b7f","cfxTxOeVZIK668P7Hc027v","5eTUjEDjRFr6JoiUhRl+i8","6fiRp7WghI5phB3bNkrIax@6c48a","a7YStUNeNCOKGpSntUY1g5","955bAq4zhCPL27F0htsdnr@6c48a","1brw/JvvpFnIvdrxpFCgMZ","aeGN7qxuBKPb9w7lUz+bqH@6c48a","a3zQCfCrBCDZJ4uf2rk5u8","e3VTytLxVCk4Waj0PHgPKJ@18751","e3VTytLxVCk4Waj0PHgPKJ@30732","e3VTytLxVCk4Waj0PHgPKJ@da6f3","e3VTytLxVCk4Waj0PHgPKJ@f1394","e3VTytLxVCk4Waj0PHgPKJ@4b929","e3VTytLxVCk4Waj0PHgPKJ@75ee4","8eBHF49hxDIqL20a2yi2ri","e3VTytLxVCk4Waj0PHgPKJ@39f7b","e3VTytLxVCk4Waj0PHgPKJ@a72ab"],["_parent","node","_mesh","_skeleton","_defaultClip","root","mainTexture","_effectAsset","data","asset","scene","_envmapHDR","_envmapLDR"],[["cc.Node",["_name","_objFlags","__editorExtras__","_id","_prefab","_parent","_lpos","_children","_lrot","_euler","_components","_lscale"],-1,4,1,5,2,5,5,9,5],"cc.ImageAsset","cc.Texture2D",["cc.SkeletalAnimation",["playOnLoad","_name","node","__prefab","_clips","_defaultClip"],1,1,4,3,6],["cc.SkinnedMeshRenderer",["_shadowCastingMode","node","__prefab","_materials","bakeSettings","_skinningRoot","_mesh","_skeleton"],2,1,4,3,4,1,6,6],["RenderQueueDesc",["stages","isTransparent","sortMode"],0],"cc.TextureCube",["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Prefab",["_name"],2],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_euler"],2,1,9,4,5,5,5],["cc.Node",["_name","_parent","_children","_prefab","_lpos","_lrot","_euler"],2,1,12,4,5,5,5],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.PrefabInfo",["root","asset","instance","targetOverrides","nestedPrefabInstanceRoots"],0,9,2],["cc.CompPrefabInfo",["fileId"],2],["cc.ModelBakeSettings",[],3],["cc.SceneAsset",["_name"],2],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,4],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["cc.TargetInfo",["localID"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.TargetOverrideInfo",["propertyPath","source","sourceInfo","target","targetInfo"],2,1,4,1,4],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","skin","lightProbeInfo","postSettings"],3,4,4,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR"],2,5,5],["cc.ShadowsInfo",["_enabled","_type","_distance","_shadowColor","_size"],0,5,5],["cc.SkyboxInfo",["_enabled","_envmapHDR","_envmapLDR"],2,6,6],["cc.FogInfo",["_fogColor"],3,5],["cc.OctreeInfo",[],3],["cc.SkinInfo",[],3],["cc.LightProbeInfo",[],3],["cc.PostSettingsInfo",[],3],["cc.DirectionalLight",["_illuminanceHDR","_illuminanceLDR","_shadowEnabled","_shadowPcf","_shadowBias","_shadowSaturation","_shadowDistance","_csmLevel","_shadowFar","_shadowOrthoSize","node","_staticSettings"],-7,1,4],["cc.StaticLightSettings",[],3],["cc.Camera",["_clearFlags","_visibility","node"],1,1],["cc.Material",["_name","_states","_defines","_props"],0,12],["cc.Skeleton",["_name","_hash","_joints","_bindposes"],0,12],["cc.Mesh",["_native","_hash","_struct"],1,11],["ForwardPipeline",["_flows"],3,9],["ShadowFlow",["_name","_stages"],2,9],["ShadowStage",["_name"],2],["ForwardFlow",["_name","_priority","_stages"],1,9],["ForwardStage",["_name","renderQueues"],2,9]],[[11,0,1,2,3,4,5,5],[20,0,2],[15,1],[9,0,1,2,3,4,5,6,2],[14,0,2],[0,0,5,4,6,8,9,2],[0,0,5,7,4,6,8,11,9,2],[18,0,1,2,2],[0,0,5,10,4,8,11,9,2],[4,1,2,3,4,5,6,7,1],[0,0,5,7,4,2],[19,0,1,2,3],[0,0,5,7,4,6,8,9,2],[0,0,5,7,10,4,6,8,11,9,2],[3,1,0,2,3,4,5,3],[36,0,1,2,3,4],[37,0,1,2,3],[22,0,1,2,3,4,2],[3,0,2,3,4,5,2],[35,0,1,2,3,4],[7,0,1,2,4],[8,0,2],[0,0,3,5,10,6,8,9,3],[0,0,5,4,6,2],[12,0,1,2,3,4,5,4],[17,0,1,2,3],[0,0,7,4,2],[0,0,5,7,10,4,6,11,2],[0,1,2,4,3],[0,1,2,5,4,3],[0,0,7,10,4,6,2],[0,0,7,4,6,8,9,2],[0,0,7,4,6,2],[0,0,5,7,4,8,9,2],[0,0,5,4,6,8,11,9,2],[0,0,5,7,4,6,2],[0,0,5,10,4,6,8,11,9,2],[10,0,1,2,3,4,5,6,2],[13,0,1,2,3,4,4],[4,0,1,2,3,4,5,6,7,2],[16,0,2],[21,0,1,2,3,2],[23,0,1,2,3,4,5,6,7,1],[24,0,1,2,2],[25,0,1,2,3,4,4],[26,0,1,2,2],[27,0,1],[28,1],[29,1],[30,1],[31,1],[32,0,1,2,3,4,5,6,7,8,9,10,11,11],[33,1],[34,0,1,2,3],[38,0,1],[39,0,1,2],[40,0,2],[41,0,1,2,3],[42,0,1,2],[5,0,2],[5,1,2,0,4]],[[[[20,"legacy/standard",[{"hash":3068622383,"name":"legacy/standard|standard-vs|standard-fs","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]},{"name":"a_color","format":44,"location":17,"defines":["USE_VERTEX_COLOR"]},{"name":"a_texCoord1","format":21,"location":18,"defines":[]}],"fragColors":[{"name":"fragColorX","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":["CC_FORWARD_ADD"]},{"name":"albedoOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":1,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"emissiveOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":2,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]},{"name":"normalOut","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":3,"defines":["CC_FORWARD_ADD","CC_PIPELINE_TYPE"]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_ALBEDO_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":["USE_PBR_MAP"]},{"name":"metallicRoughnessMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":["USE_METALLIC_ROUGHNESS_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[{"name":"b_ccLightsBuffer","memoryAccess":1,"stageFlags":16,"binding":7,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightIndicesBuffer","memoryAccess":1,"stageFlags":16,"binding":8,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]},{"name":"b_clusterLightGridBuffer","memoryAccess":1,"stageFlags":16,"binding":9,"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nout mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBiasAndProbeId.x + cc_shadowWHPBInfo.w, a_localShadowBiasAndProbeId.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    out mediump vec4 v_sh_linear_const_r;\n    out mediump vec4 v_sh_linear_const_g;\n    out mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\nvoid CC_TRANSFER_SH() {\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out lowp vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  out mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  out mediump vec4 v_reflectionProbeData;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  out vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBiasAndProbeId.xy = CCGetShadowBias();\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      v_shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      v_shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n      v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  CC_TRANSFER_SH();\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nin mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  vec4 shadowTexure(highp sampler2D shadowMap, vec2 coord) {\n      #if defined(CC_USE_WGPU)\n          return textureLod(shadowMap, coord, 0.0);\n      #else\n        return texture(shadowMap, coord);\n      #endif\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(shadowTexure(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, shadowTexure(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n      return textureLod(tex, coord, lod);\n}\nuniform samplerCube cc_environment;\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n#endif\n#if CC_USE_LIGHT_PROBE\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    in mediump vec4 v_sh_linear_const_r;\n    in mediump vec4 v_sh_linear_const_g;\n    in mediump vec4 v_sh_linear_const_b;\n  #else\n    layout(std140) uniform CCSH {\n      vec4 cc_sh_linear_const_r;\n      vec4 cc_sh_linear_const_g;\n      vec4 cc_sh_linear_const_b;\n      vec4 cc_sh_quadratic_r;\n      vec4 cc_sh_quadratic_g;\n      vec4 cc_sh_quadratic_b;\n      vec4 cc_sh_quadratic_a;\n    };\n  #endif\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity, vec2 screenUV) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        vec4 biased = fragTextureLod(cc_reflectionProbeCubemap, R, mip + mipBias);\n     \t  vec4 filtered = texture(cc_reflectionProbeCubemap, R);\n      #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n        vec4 biased = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mip + mipBias);\n        vec4 filtered = texture(cc_reflectionProbePlanarMap, screenUV);\n      #else\n        vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \t  vec4 filtered = texture(cc_environment, R);\n      #endif\n      #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n        biased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    float reflectionProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    float reflectionProbeBlendId;\n    float reflectionProbeBlendFactor;\n  #endif\n};\n vec3 SampleReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    vec4 envmap = fragTextureLod(tex, R, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      #endif\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      #endif\n    }\n  #endif\n  vec3 finalColor = vec3(0.0);\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    #if CC_USE_LIGHTMAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n      shadow *= s.lightmap.a;\n      finalColor += diffuse * lightmap.rgb;\n    #else\n      finalColor += diffuse * lightmap.rgb * shadow;\n    #endif\n    s.occlusion *= s.lightmap_test;\n  #endif\n  #if !CC_DISABLE_DIRECTIONAL_LIGHT\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 lightingColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor += lightingColor * dirlightContrib;\n  #endif\n  float fAmb = max(EPSILON, 0.5 - N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 env = vec3(0.0), rotationDir;\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      rotationDir = RotationVecFromAxisY(N.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = texture(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if !CC_USE_REFLECTION_PROBE\n      vec3 R = normalize(reflect(-V, N));\n      rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6, vec2(0.0));\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n        #if CC_USE_IBL == 2\n          env = unpackRGBE(envmap);\n        #else\n          env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n    #endif\n  #endif\n  float lightIntensity = cc_ambientSky.w;\n  #if CC_USE_REFLECTION_PROBE\n    vec4 probe = vec4(0.0);\n    vec3 R = normalize(reflect(-V, N));\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      if(s.reflectionProbeId < 0.0){\n        env = SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2);\n      }else{\n        vec3 centerPos, boxHalfSize;\n        float mipCount;\n        GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, s.reflectionProbeId);\n        vec4 fixedR = CalculateBoxProjectedDirection(R, position, centerPos, boxHalfSize);\n        env = mix(SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2) * lightIntensity,\n          SampleReflectionProbe(cc_reflectionProbeCubemap, fixedR.xyz, s.roughness, mipCount, isReflectProbeUsingRGBE(s.reflectionProbeId)), fixedR.w);\n      }\n    #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n      if(s.reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(s.position, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0);\n      }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, s.reflectionProbeId);\n        R = normalize(CalculateReflectDirection(N, V, max(abs(dot(N, V)), 0.0)));\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(N, V, s.position, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount);\n      }\n      env = unpackRGBE(probe);\n    #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n      if (s.reflectionProbeId < 0.0) {\n        env = SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2);\n      } else {\n        vec3 centerPos, boxHalfSize;\n        float mipCount;\n        GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, s.reflectionProbeId);\n        vec4 fixedR = CalculateBoxProjectedDirection(R, s.position, centerPos, boxHalfSize);\n        env = SampleReflectionProbe(cc_reflectionProbeCubemap, fixedR.xyz, s.roughness, mipCount, isReflectProbeUsingRGBE(s.reflectionProbeId));\n        if (s.reflectionProbeBlendId < 0.0) {\n          vec3 skyBoxEnv = SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2) * lightIntensity;\n          #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n            env = mix(env, skyBoxEnv, s.reflectionProbeBlendFactor);\n          #else\n            env = mix(skyBoxEnv, env, fixedR.w);\n          #endif\n        }\n      }\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = s.reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  finalColor += env * lightIntensity * specular * s.occlusion;\n#if CC_USE_LIGHT_PROBE\n  finalColor += SHEvaluate(N) * diffuse * s.occlusion;\n#endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nin highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  in vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture(lightingMap, luv);\n  \tvec4 dataHigh = texture(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n#endif\nin vec3 v_position;\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in mediump vec2 v_uv1;\n#endif\nin vec3 v_normal;\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  in mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  in mediump vec4 v_reflectionProbeData;\n#endif\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBiasAndProbeId.xy;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    s.reflectionProbeId = v_shadowBiasAndProbeId.z;\n  #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    s.reflectionProbeBlendId = v_shadowBiasAndProbeId.w;\n    #if USE_INSTANCING\n      s.reflectionProbeBlendFactor = v_reflectionProbeData.x;\n    #else\n      s.reflectionProbeBlendFactor = cc_reflectionProbeBlendData1.w;\n    #endif\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * (v_tangent.w > 0.0 ? 1.0 : -1.0);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    SampleAndDecodeLightMapColor(s.lightmap.rgb, s.lightmap.a, s.lightmap_test, cc_lightingMap, v_luv.xy, v_luv.z, s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  vec4 pbr = pbrParams;\n  pbr.x = 1.0;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x = mix(1.0, res.r, pbrParams.x);\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x = mix(1.0, texture(occlusionMap, PBR_UV).r, pbrParams.x);\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.specularIntensity = pbr.w;\n  s.emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n    s.emissive = SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  s.emissive *= emissiveScaleParam.xyz;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n    vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  float GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n    vec3 v = vec3(0.0);\n    vec3 up = cross(right, lookAt);\n    worldPos -= lightPos;\n    v.x = dot(worldPos, right);\n    v.y = dot(worldPos, up);\n    v.z = dot(worldPos, lookAt);\n    vec3 result = step(abs(v), BoundingHalfSizeVS);\n    return result.x * result.y * result.z;\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -cc_lightDir[i].xyz : cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      float illum = 1.0;\n      float att = 1.0;\n      if (IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n        att = GetOutOfRange(position, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n      } else {\n        float distSqr = dot(SLU, SLU);\n        float litRadius = cc_lightSizeRangeAngle[i].x;\n        float litRadiusSqr = litRadius * litRadius;\n        illum = (IS_POINT_LIGHT(cc_lightPos[i].w) || IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distSqr);\n        float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n        attRadiusSqrInv *= attRadiusSqrInv;\n        att = GetDistAtt(distSqr, attRadiusSqrInv);\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n          float cosOuter = cc_lightSizeRangeAngle[i].z;\n          float strength = clamp(cc_lightBoundingSizeVS[i].w, 0.0, 1.0);\n          float litAngleScale = 1.0 / max(0.001, mix(cosInner, 1.0, strength) - cosOuter);\n          float litAngleOffset = -cosOuter * litAngleScale;\n          att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n        }\n      }\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w) && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      finalColor += SNL * cc_lightColor[i].rgb * shadow * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  layout(std430, binding = 0) readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  layout(std430, binding = 1) readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  layout(std430, binding = 2) readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n    vec4 cc_lightBoundingSizeVS;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[5u * i + 0u];\n    light.cc_lightColor = b_ccLights[5u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[5u * i + 2u];\n    light.cc_lightDir = b_ccLights[5u * i + 3u];\n    light.cc_lightBoundingSizeVS = b_ccLights[5u * i + 4u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24u) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24u) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16u));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8u));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 200u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (IS_SPOT_LIGHT(light.cc_lightPos.w)) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (IS_SPOT_LIGHT(light.cc_lightPos.w)  && light.cc_lightSizeRangeAngle.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  layout(location = 0) out vec4 fragColorX;\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG(color, s.position.xyz);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG(color, s.position.xyz);\n      #endif\n    #endif\n    fragColorX = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  layout(location = 0) out vec4 albedoOut;\n  layout(location = 1) out vec4 emissiveOut;\n  layout(location = 2) out vec4 normalOut;\n  void main () {\n    StandardSurface s; surf(s);\n    albedoOut = s.albedo;\n    normalOut = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    emissiveOut = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"glsl1":{"vert":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_lightingMapUVParam;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBiasAndProbeId.x + cc_shadowWHPBInfo.w, a_localShadowBiasAndProbeId.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #endif\n#endif\nvoid CC_TRANSFER_SH() {\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    v_sh_linear_const_r = a_sh_linear_const_r;\n    v_sh_linear_const_g = a_sh_linear_const_g;\n    v_sh_linear_const_b = a_sh_linear_const_b;\n  #endif\n#endif\n}\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  void CCLightingMapCaclUV()\n  {\n  #if !USE_INSTANCING\n    v_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.z;\n    v_luv.z = cc_lightingMapUVParam.w;\n  #else\n    v_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.z;\n    v_luv.z = a_lightingMapUVParam.w;\n  #endif\n  }\n#endif\nvoid main () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if CC_RECEIVE_SHADOW\n    v_shadowBiasAndProbeId.xy = CCGetShadowBias();\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    #if USE_INSTANCING\n      v_shadowBiasAndProbeId.zw = a_localShadowBiasAndProbeId.zw;\n    #else\n      v_shadowBiasAndProbeId.zw = cc_localShadowBias.zw;\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n      v_reflectionProbeData = a_reflectionProbeData;\n  #endif\n  #if USE_TWOSIDE\n    vec3 viewDirect = normalize(cc_cameraPos.xyz - v_position);\n    v_normal *= dot(v_normal, viewDirect) < 0.0 ? -1.0 : 1.0;\n  #endif\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if SAMPLE_FROM_RT\n    v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n  #endif\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n    #endif\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  CC_TRANSFER_FOG(pos);\n  v_shadowPos = cc_matLightViewProj * pos;\n  CC_TRANSFER_SH();\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n  gl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}","frag":"\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_probeInfo;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_surfaceTransform;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n  uniform mediump vec4 cc_ambientSky;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n  uniform mediump vec4 cc_nearFar;\n  uniform mediump vec4 cc_viewPort;\n     uniform vec4 albedo;\n     uniform vec4 albedoScaleAndCutoff;\n     uniform vec4 pbrParams;\n     uniform vec4 emissive;\n     uniform vec4 emissiveScaleParam;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nuniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowInvProjDepthInfo;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nvec2 GetPlanarReflectScreenUV(vec3 worldPos, mat4 matVirtualCameraViewProj, float flipNDCSign, vec3 viewDir, vec3 reflectDir)\n{\n  vec4 clipPos = matVirtualCameraViewProj * vec4(worldPos, 1.0);\n  vec2 screenUV = clipPos.xy / clipPos.w * 0.5 + 0.5;\n  screenUV = vec2(1.0 - screenUV.x, screenUV.y);\n  screenUV = flipNDCSign == 1.0 ? vec2(screenUV.x, 1.0 - screenUV.y) : screenUV;\n  return screenUV;\n}\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nvec3 RotationVecFromAxisY(vec3 v, float cosTheta, float sinTheta)\n{\n    vec3 result;\n    result.x = dot(v, vec3(cosTheta, 0.0, -sinTheta));\n    result.y = v.y;\n    result.z = dot(v, vec3(sinTheta, 0.0,  cosTheta));\n    return result;\n}\nvec3 RotationVecFromAxisY(vec3 v, float rotateAngleArc)\n{\n  return RotationVecFromAxisY(v, cos(rotateAngleArc), sin(rotateAngleArc));\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n    highp float unpackHighpData (float mainPart, float modPart) {\n      highp float data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n      highp float data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n      highp float divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n      highp vec2 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n      highp vec2 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n      highp vec2 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n      highp vec3 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n      highp vec3 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n      highp vec3 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n      highp vec4 data = mainPart;\n      return data + modPart;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n      mainPart = fract(data);\n      modPart = data - mainPart;\n    }\n    highp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n      highp vec4 data = mainPart * modValue;\n      return data + modPart * modValue;\n    }\n    void packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n      highp vec4 divide = data / modValue;\n      mainPart = floor(divide);\n      modPart = (data - mainPart * modValue) / modValue;\n    }\n  vec4 shadowTexure(highp sampler2D shadowMap, vec2 coord) {\n      #if defined(CC_USE_WGPU)\n          return texture2DLod(shadowMap, coord, 0.0);\n      #else\n        return texture2D(shadowMap, coord);\n      #endif\n  }\n  float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    #if CC_SHADOWMAP_FORMAT == 1\n      return step(shadowNDCPos.z, dot(shadowTexure(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      return step(shadowNDCPos.z, shadowTexure(shadowMap, shadowNDCPos.xy).x);\n    #endif\n  }\n  float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n    float block0, block1, block2, block3;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n      block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n      block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n    #endif\n    float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block2, block3, coefX);\n    float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    return mix(resultX, resultY, coefY);\n  }\n  float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n    float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n    float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n    float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n    float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n      block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n      block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n      block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n      block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n      block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n      block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n      block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n      block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n    #endif\n    float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n    float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n    float shadow = 0.0;\n    float resultX = mix(block0, block1, coefX);\n    float resultY = mix(block3, block4, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block1, block2, coefX);\n    resultY = mix(block4, block5, coefX);\n    shadow += mix(resultX , resultY, coefY);\n    resultX = mix(block3, block4, coefX);\n    resultY = mix(block6, block7, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    resultX = mix(block4, block5, coefX);\n    resultY = mix(block7, block8, coefX);\n    shadow += mix(resultX, resultY, coefY);\n    return shadow * 0.25;\n  }\n  float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n  {\n    vec2 oneTap = 1.0 / shadowMapResolution;\n    vec2 twoTap = oneTap * 2.0;\n    vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n    vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n    vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n    vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n    vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n    vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n    vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n    vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n    vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n    vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n    vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n    vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n    vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n    vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n    vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n    vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n    vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n    vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n    vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n    vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n    vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n    vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n    vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n    vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n    vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n    float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n    #if CC_SHADOWMAP_FORMAT == 1\n      block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block9 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block10 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block11 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block12 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block13 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block14 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block15 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block16 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block17 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block18 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block19 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block20 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block21 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block22 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block23 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block24 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n      block25 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n    #else\n      block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset1).x);\n      block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset2).x);\n      block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset3).x);\n      block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset4).x);\n      block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset5).x);\n      block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset6).x);\n      block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset7).x);\n      block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset8).x);\n      block9 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset9).x);\n      block10 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset10).x);\n      block11 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset11).x);\n      block12 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset12).x);\n      block13 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset13).x);\n      block14 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset14).x);\n      block15 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset15).x);\n      block16 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset16).x);\n      block17 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset17).x);\n      block18 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset18).x);\n      block19 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset19).x);\n      block20 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset20).x);\n      block21 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset21).x);\n      block22 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset22).x);\n      block23 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset23).x);\n      block24 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset24).x);\n      block25 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset25).x);\n    #endif\n    vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n    vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n    vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n    vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n    vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n    float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n    vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n    vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n    vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n    vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n    float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n    vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n    vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n    vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n    vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n    float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n    vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n    vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n    vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n    vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n    float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n    float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n    return fAvg;\n  }\n  bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n  {\n  \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n  \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n  \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n  \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n  \t\treturn false;\n  \t}\n  \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n  \treturn true;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n  {\n    vec4 newShadowPos = shadowPos;\n    if (normalBias > EPSILON_LOWP)\n    {\n      vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n      if (viewNormal.z < 0.1)\n        newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n    }\n    return newShadowPos;\n  }\n  vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n  {\n  \tvec4 newShadowPos = shadowPos;\n  \tif (normalBias > EPSILON_LOWP)\n  \t{\n  \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n  \t\tif (viewNormal.z < 0.1)\n  \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n  \t}\n  \treturn newShadowPos;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n  {\n  \treturn (NDCDepth - projBiasZ) / projScaleZ;\n  }\n  float GetViewSpaceDepthFromNDCDepth_Perspective(float NDCDepth, float homogenousDividW, float invProjScaleZ, float invProjBiasZ)\n  {\n  \treturn NDCDepth * invProjScaleZ + homogenousDividW * invProjBiasZ;\n  }\n  vec4 ApplyShadowDepthBias_Perspective(vec4 shadowPos, float viewspaceDepthBias)\n  {\n  \tvec3 viewSpacePos;\n  \tviewSpacePos.xy = shadowPos.xy * cc_shadowProjInfo.zw;\n  \tviewSpacePos.z = GetViewSpaceDepthFromNDCDepth_Perspective(shadowPos.z, shadowPos.w, cc_shadowInvProjDepthInfo.x, cc_shadowInvProjDepthInfo.y);\n  \tviewSpacePos.xyz += cc_shadowProjDepthInfo.z * normalize(viewSpacePos.xyz) * viewspaceDepthBias;\n  \tvec4 clipSpacePos;\n  \tclipSpacePos.xy = viewSpacePos.xy * cc_shadowProjInfo.xy;\n  \tclipSpacePos.zw = viewSpacePos.z * cc_shadowProjDepthInfo.xz + vec2(cc_shadowProjDepthInfo.y, 0.0);\n  \t#if CC_SHADOWMAP_USE_LINEAR_DEPTH\n  \t\tclipSpacePos.z = GetLinearDepthFromViewSpace(viewSpacePos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n  \t\tclipSpacePos.z = (clipSpacePos.z * 2.0 - 1.0) * clipSpacePos.w;\n  \t#endif\n  \treturn clipSpacePos;\n  }\n  vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n  {\n  \tfloat coeffA = projScaleZ;\n  \tfloat coeffB = projBiasZ;\n  \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n  \tviewSpacePos_z += viewspaceDepthBias;\n  \tvec4 result = shadowPos;\n  \tresult.z = viewSpacePos_z * coeffA + coeffB;\n  \treturn result;\n  }\n  vec4 ApplyShadowDepthBias_PerspectiveLinearDepth(vec4 shadowPos, float viewspaceDepthBias, vec3 worldPos)\n  {\n    shadowPos.z = CCGetLinearDepth(worldPos, viewspaceDepthBias) * 2.0 - 1.0;\n    shadowPos.z *= shadowPos.w;\n    return shadowPos;\n  }\n  float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorHard (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorHard(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCGetSpotLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias, vec3 worldPos) {\n\t  vec3 shadowNDCPos;\n\t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n\t\t  return 1.0;\n\t  }\n    return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_spotShadowMap, cc_shadowWHPBInfo.xy);\n  }\n  float CCSpotShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    float pcf = cc_shadowWHPBInfo.z;\n    vec4 pos = vec4(1.0);\n    #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n      pos = ApplyShadowDepthBias_PerspectiveLinearDepth(shadowPos, shadowBias.x, worldPos);\n    #else\n      pos = ApplyShadowDepthBias_Perspective(shadowPos, shadowBias.x);\n    #endif\n    float realtimeShadow = 1.0;\n    if (pcf > 2.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft5X(pos, worldPos);\n    }else if (pcf > 1.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft3X(pos, worldPos);\n    }else if (pcf > 0.9) {\n      realtimeShadow = CCGetSpotLightShadowFactorSoft(pos, worldPos);\n    }else {\n      realtimeShadow = CCGetSpotLightShadowFactorHard(pos, worldPos);\n    }\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n  {\n    vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n    pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n    float realtimeShadow = 1.0;\n    #if CC_DIR_SHADOW_PCF_TYPE == 3\n      realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 2\n      realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 1\n      realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n    #endif\n    #if CC_DIR_SHADOW_PCF_TYPE == 0\n      realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n    #endif\n    shadowPosWithDepthBias = pos;\n    return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n  }\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n    bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n      highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n      highp float minRange = cc_csmSplitsInfo.x;\n      highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n      ratio = 0.0;\n      if (clipPos.x <= minRange) {\n        ratio = clipPos.x * thresholdInvert;\n        return true;\n      }\n      if (clipPos.x >= maxRange) {\n        ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y <= minRange) {\n        ratio = clipPos.y  * thresholdInvert;\n        return true;\n      }\n      if (clipPos.y >= maxRange) {\n        ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n        return true;\n      }\n      return false;\n    }\n    bool CCHasCSMLevel(int level, vec3 worldPos) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      bool hasLevel = false;\n      for (int i = 0; i < 4; i++) {\n        if (i == level) {\n          vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n          if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n              clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n              clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n            hasLevel = true;\n          }\n        }\n      }\n      return hasLevel;\n    }\n    void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n        }\n      }\n    }\n    int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      int level = -1;\n      highp float layerThreshold = cc_csmViewDir0[0].w;\n      for (int i = 0; i < 4; i++) {\n        vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n            clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n            clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n          #if CC_CASCADED_LAYERS_TRANSITION\n            isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n          #endif\n          csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n          csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n          shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n          shadowProjInfo = cc_csmProjInfo[i];\n          shadowViewDir0 = cc_csmViewDir0[i].xyz;\n          shadowViewDir1 = cc_csmViewDir1[i].xyz;\n          shadowViewDir2 = cc_csmViewDir2[i].xyz;\n          level = i;\n        }\n      }\n      return level;\n    }\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n    {\n      bool isTransitionArea = false;\n      highp float transitionRatio = 0.0;\n      return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n    {\n      bool isTransitionArea = false;\n      highp float ratio = 0.0;\n      csmPos = vec4(1.0);\n      vec4 shadowProjDepthInfo, shadowProjInfo;\n      vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n      int level = -1;\n      #if CC_CASCADED_LAYERS_TRANSITION\n        level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #else\n        level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n      #endif\n      if (level < 0) { return 1.0; }\n      vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n      pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n      csmPosWithBias = pos;\n      float realtimeShadow = 1.0;\n      #if CC_DIR_SHADOW_PCF_TYPE == 3\n        realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 2\n        realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 1\n        realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n      #endif\n      #if CC_DIR_SHADOW_PCF_TYPE == 0\n        realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n      #endif\n      #if CC_CASCADED_LAYERS_TRANSITION\n        vec4 nextCSMPos = vec4(1.0);\n        vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n        vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n        float nextRealtimeShadow = 1.0;\n        CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n        bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n        if (hasNextLevel && isTransitionArea) {\n          vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n          nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n          #endif\n          return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n        }\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #else\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      #endif\n    }\n  #else\n    int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n      return -1;\n    }\n    float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n      csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n      return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n    }\n  #endif\n  float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n    vec4 shadowPosWithDepthBias;\n    return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n  }\n  float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n    vec4 csmPos, csmPosWithBias;\n    return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n  }\n  float CCSpotShadowFactorBase(vec4 shadowPos, vec3 worldPos, vec2 shadowBias)\n  {\n    vec4 shadowPosWithDepthBias;\n    return CCSpotShadowFactorBase(shadowPosWithDepthBias, shadowPos, worldPos, shadowBias);\n  }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nuniform samplerCube cc_environment;\nvec3 CalculateReflectDirection(vec3 N, vec3 V, float NoV)\n{\n  float sideSign = NoV < 0.0 ? -1.0 : 1.0;\n  N *= sideSign;\n  return reflect(-V, N);\n}\nvec3 CalculatePlanarReflectPositionOnPlane(vec3 N, vec3 V, vec3 worldPos, vec4 plane, vec3 cameraPos, float probeReflectedDepth)\n{\n  float distPixelToPlane = -dot(plane, vec4(worldPos, 1.0));\n  plane.w += distPixelToPlane;\n  float distCameraToPlane = abs(-dot(plane, vec4(cameraPos, 1.0)));\n  vec3 planeN = plane.xyz;\n  vec3 virtualCameraPos = cameraPos - 2.0 * distCameraToPlane * planeN;\n  vec3 bumpedR = normalize(reflect(-V, N));\n  vec3 reflectedPointPos = worldPos + probeReflectedDepth * bumpedR;\n  vec3 virtualCameraToReflectedPoint = normalize(reflectedPointPos - virtualCameraPos);\n  float y = distCameraToPlane / max(EPSILON_LOWP, dot(planeN, virtualCameraToReflectedPoint));\n  return virtualCameraPos + y * virtualCameraToReflectedPoint;\n}\nvec4 CalculateBoxProjectedDirection(vec3 R, vec3 worldPos, vec3 cubeCenterPos, vec3 cubeBoxHalfSize)\n{\n  vec3 W = worldPos - cubeCenterPos;\n  vec3 projectedLength = (sign(R) * cubeBoxHalfSize - W) / (R + vec3(EPSILON));\n  float len = min(min(projectedLength.x, projectedLength.y), projectedLength.z);\n  vec3 P = W + len * R;\n  float weight = len < 0.0 ? 0.0 : 1.0;\n  return vec4(P, weight);\n}\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  uniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\n  uniform highp vec4 cc_reflectionProbeBlendData1;\n  vec4 GetTexData(sampler2D dataMap, float dataMapWidth, float x, float uv_y)\n  {\n    return vec4(\n        decode32(texture2D(dataMap, vec2(((x + 0.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 1.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 2.5)/dataMapWidth), uv_y))),\n        decode32(texture2D(dataMap, vec2(((x + 3.5)/dataMapWidth), uv_y)))\n      );\n  }\n  void GetPlanarReflectionProbeData(out vec4 plane, out float planarReflectionDepthScale, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        plane.xyz = texData1.xyz;\n        plane.w = texData2.x;\n        planarReflectionDepthScale = texData2.y;\n        mipCount = texData2.z;\n      #else\n        plane = cc_reflectionProbeData1;\n        planarReflectionDepthScale = cc_reflectionProbeData2.x;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n  }\n  void GetCubeReflectionProbeData(out vec3 centerPos, out vec3 boxHalfSize, out float mipCount, float probeId)\n  {\n      #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData1 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 0.0, uv_y);\n        vec4 texData2 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 4.0, uv_y);\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        centerPos = texData1.xyz;\n        boxHalfSize = texData2.xyz;\n        mipCount = texData3.x;\n      #else\n        centerPos = cc_reflectionProbeData1.xyz;\n        boxHalfSize = cc_reflectionProbeData2.xyz;\n        mipCount = cc_reflectionProbeData2.w;\n      #endif\n      if (mipCount > 1000.0) mipCount -= 1000.0;\n  }\n  bool isReflectProbeUsingRGBE(float probeId)\n  {\n    #if USE_INSTANCING\n        float uv_y = (probeId + 0.5) / cc_probeInfo.x;\n        float dataMapWidth = 12.0;\n        vec4 texData3 = GetTexData(cc_reflectionProbeDataMap, dataMapWidth, 8.0, uv_y);\n        return texData3.x > 1000.0;\n    #else\n      return cc_reflectionProbeData2.w > 1000.0;\n    #endif\n  }\n#endif\n#if CC_USE_LIGHT_PROBE\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #else\n    uniform vec4 cc_sh_linear_const_r;\n  uniform vec4 cc_sh_linear_const_g;\n  uniform vec4 cc_sh_linear_const_b;\n  uniform vec4 cc_sh_quadratic_r;\n  uniform vec4 cc_sh_quadratic_g;\n  uniform vec4 cc_sh_quadratic_b;\n  uniform vec4 cc_sh_quadratic_a;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n  vec3 SHEvaluate(vec3 normal)\n  {\n      vec3 result;\n  #if USE_INSTANCING\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(v_sh_linear_const_r, normal4);\n      result.g = dot(v_sh_linear_const_g, normal4);\n      result.b = dot(v_sh_linear_const_b, normal4);\n  #else\n      vec4 normal4 = vec4(normal, 1.0);\n      result.r = dot(cc_sh_linear_const_r, normal4);\n      result.g = dot(cc_sh_linear_const_g, normal4);\n      result.b = dot(cc_sh_linear_const_b, normal4);\n      vec4 n14 = normal.xyzz * normal.yzzx;\n      float n5 = normal.x * normal.x - normal.y * normal.y;\n      result.r += dot(cc_sh_quadratic_r, n14);\n      result.g += dot(cc_sh_quadratic_g, n14);\n      result.b += dot(cc_sh_quadratic_b, n14);\n      result += (cc_sh_quadratic_a.rgb * n5);\n  #endif\n    #if CC_USE_HDR\n      result *= cc_exposure.w * cc_exposure.x;\n    #endif\n    return result;\n  }\n  #endif\n#endif\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / max(EPSILON, OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return max(vec3(0.0), specular * AB.x + AB.y);\n}\n#if USE_REFLECTION_DENOISE\n  vec3 GetEnvReflectionWithMipFiltering(vec3 R, float roughness, float mipCount, float denoiseIntensity, vec2 screenUV) {\n    #if CC_USE_IBL\n    \tfloat mip = roughness * (mipCount - 1.0);\n    \tfloat delta = (dot(dFdx(R), dFdy(R))) * 1000.0;\n    \tfloat mipBias = mix(0.0, 5.0, clamp(delta, 0.0, 1.0));\n      #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n        vec4 biased = fragTextureLod(cc_reflectionProbeCubemap, R, mip + mipBias);\n     \t  vec4 filtered = textureCube(cc_reflectionProbeCubemap, R);\n      #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n        vec4 biased = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mip + mipBias);\n        vec4 filtered = texture2D(cc_reflectionProbePlanarMap, screenUV);\n      #else\n        vec4 biased = fragTextureLod(cc_environment, R, mip + mipBias);\n     \t  vec4 filtered = textureCube(cc_environment, R);\n      #endif\n      #if CC_USE_IBL == 2 || CC_USE_REFLECTION_PROBE != REFLECTION_PROBE_TYPE_NONE\n        biased.rgb = unpackRGBE(biased);\n      \tfiltered.rgb = unpackRGBE(filtered);\n      #else\n      \tbiased.rgb = SRGBToLinear(biased.rgb);\n      \tfiltered.rgb = SRGBToLinear(filtered.rgb);\n      #endif\n      return mix(biased.rgb, filtered.rgb, denoiseIntensity);\n    #else\n      return vec3(0.0, 0.0, 0.0);\n    #endif\n  }\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    float reflectionProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    float reflectionProbeBlendId;\n    float reflectionProbeBlendFactor;\n  #endif\n};\n vec3 SampleReflectionProbe(samplerCube tex, vec3 R, float roughness, float mipCount, bool isRGBE) {\n    vec4 envmap = fragTextureLod(tex, R, roughness * (mipCount - 1.0));\n    if (isRGBE)\n      return unpackRGBE(envmap);\n    else\n      return SRGBToLinear(envmap.rgb);\n  }\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.08 * s.specularIntensity), s.albedo.rgb, s.metallic);\n  vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = max(dot(N, L), 0.0);\n  float shadow = 1.0;\n  #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if (NL > 0.0 && cc_mainLitDir.w > 0.0) {\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      #endif\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n        shadow = CCShadowFactorBase(shadowPos, N, s.shadowBias);\n      #endif\n    }\n  #endif\n  vec3 finalColor = vec3(0.0);\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    vec3 lightmap = s.lightmap.rgb;\n    #if CC_USE_HDR\n        lightmap.rgb *= cc_exposure.w * cc_exposure.x;\n    #endif\n    #if CC_USE_LIGHTMAP == LIGHT_MAP_TYPE_INDIRECT_OCCLUSION\n      shadow *= s.lightmap.a;\n      finalColor += diffuse * lightmap.rgb;\n    #else\n      finalColor += diffuse * lightmap.rgb * shadow;\n    #endif\n    s.occlusion *= s.lightmap_test;\n  #endif\n  #if !CC_DISABLE_DIRECTIONAL_LIGHT\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 H = normalize(L + V);\n    float NH = max(dot(N, H), 0.0);\n    vec3 lightingColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    vec3 dirlightContrib = (diffuseContrib + specularContrib);\n    dirlightContrib *= shadow;\n    finalColor += lightingColor * dirlightContrib;\n  #endif\n  float fAmb = max(EPSILON, 0.5 - N.y * 0.5);\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb);\n  vec3 env = vec3(0.0), rotationDir;\n  #if CC_USE_IBL\n    #if CC_USE_DIFFUSEMAP && !CC_USE_LIGHT_PROBE\n      rotationDir = RotationVecFromAxisY(N.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      vec4 diffuseMap = textureCube(cc_diffuseMap, rotationDir);\n      #if CC_USE_DIFFUSEMAP == 2\n        ambDiff = unpackRGBE(diffuseMap);\n      #else\n        ambDiff = SRGBToLinear(diffuseMap.rgb);\n      #endif\n    #endif\n    #if !CC_USE_REFLECTION_PROBE\n      vec3 R = normalize(reflect(-V, N));\n      rotationDir = RotationVecFromAxisY(R.xyz, cc_surfaceTransform.z, cc_surfaceTransform.w);\n      #if USE_REFLECTION_DENOISE && !CC_IBL_CONVOLUTED\n        env = GetEnvReflectionWithMipFiltering(rotationDir, s.roughness, cc_ambientGround.w, 0.6, vec2(0.0));\n      #else\n        vec4 envmap = fragTextureLod(cc_environment, rotationDir, s.roughness * (cc_ambientGround.w - 1.0));\n        #if CC_USE_IBL == 2\n          env = unpackRGBE(envmap);\n        #else\n          env = SRGBToLinear(envmap.rgb);\n        #endif\n      #endif\n    #endif\n  #endif\n  float lightIntensity = cc_ambientSky.w;\n  #if CC_USE_REFLECTION_PROBE\n    vec4 probe = vec4(0.0);\n    vec3 R = normalize(reflect(-V, N));\n    #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_CUBE\n      if(s.reflectionProbeId < 0.0){\n        env = SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2);\n      }else{\n        vec3 centerPos, boxHalfSize;\n        float mipCount;\n        GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, s.reflectionProbeId);\n        vec4 fixedR = CalculateBoxProjectedDirection(R, position, centerPos, boxHalfSize);\n        env = mix(SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2) * lightIntensity,\n          SampleReflectionProbe(cc_reflectionProbeCubemap, fixedR.xyz, s.roughness, mipCount, isReflectProbeUsingRGBE(s.reflectionProbeId)), fixedR.w);\n      }\n    #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_PLANAR\n      if(s.reflectionProbeId < 0.0){\n        vec2 screenUV = GetPlanarReflectScreenUV(s.position, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, 1.0);\n      }else{\n        vec4 plane;\n        float planarReflectionDepthScale, mipCount;\n        GetPlanarReflectionProbeData(plane, planarReflectionDepthScale, mipCount, s.reflectionProbeId);\n        R = normalize(CalculateReflectDirection(N, V, max(abs(dot(N, V)), 0.0)));\n        vec3 worldPosOffset = CalculatePlanarReflectPositionOnPlane(N, V, s.position, plane, cc_cameraPos.xyz, planarReflectionDepthScale);\n        vec2 screenUV = GetPlanarReflectScreenUV(worldPosOffset, cc_matViewProj, cc_cameraPos.w, V, R);\n        probe = fragTextureLod(cc_reflectionProbePlanarMap, screenUV, mipCount);\n      }\n      env = unpackRGBE(probe);\n    #elif CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n      if (s.reflectionProbeId < 0.0) {\n        env = SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2);\n      } else {\n        vec3 centerPos, boxHalfSize;\n        float mipCount;\n        GetCubeReflectionProbeData(centerPos, boxHalfSize, mipCount, s.reflectionProbeId);\n        vec4 fixedR = CalculateBoxProjectedDirection(R, s.position, centerPos, boxHalfSize);\n        env = SampleReflectionProbe(cc_reflectionProbeCubemap, fixedR.xyz, s.roughness, mipCount, isReflectProbeUsingRGBE(s.reflectionProbeId));\n        if (s.reflectionProbeBlendId < 0.0) {\n          vec3 skyBoxEnv = SampleReflectionProbe(cc_environment, R, s.roughness, cc_ambientGround.w, CC_USE_IBL == 2) * lightIntensity;\n          #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n            env = mix(env, skyBoxEnv, s.reflectionProbeBlendFactor);\n          #else\n            env = mix(skyBoxEnv, env, fixedR.w);\n          #endif\n        }\n      }\n    #endif\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    lightIntensity = s.reflectionProbeId < 0.0 ? lightIntensity : 1.0;\n  #endif\n  finalColor += env * lightIntensity * specular * s.occlusion;\n#if CC_USE_LIGHT_PROBE\n  finalColor += SHEvaluate(N) * diffuse * s.occlusion;\n#endif\n  finalColor += ambDiff.rgb * cc_ambientSky.w * diffuse * s.occlusion;\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nvarying highp vec4 v_shadowPos;\n#if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n#endif\n#if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n  varying vec3 v_luv;\n  uniform sampler2D cc_lightingMap;\n  void SampleAndDecodeLightMapColor(out vec3 lightmapColor, out float dirShadow, out float ao, sampler2D lightingMap, vec2 luv, float lum, vec3 worldNormal)\n  {\n  #if CC_LIGHT_MAP_VERSION > 2\n  #elif CC_LIGHT_MAP_VERSION > 1\n  \tvec4 dataLow = texture2D(lightingMap, luv);\n  \tvec4 dataHigh = texture2D(lightingMap, luv + vec2(0.5, 0.0));\n  \tlightmapColor.xyz = dataLow.xyz + dataHigh.xyz * 0.00392156862745098;\n      lightmapColor.rgb *= lum;\n  \tdirShadow = dataLow.a;\n  \tao = dataHigh.a;\n  #else\n      vec4 lightmap = texture2D(lightingMap, luv);\n      lightmapColor = lightmap.rgb * lum;\n  \tdirShadow = lightmap.a;\n  \tao = 1.0;\n  #endif\n  }\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying mediump vec2 v_uv1;\n#endif\nvarying vec3 v_normal;\n#if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n  varying mediump vec4 v_shadowBiasAndProbeId;\n#endif\n#if CC_USE_REFLECTION_PROBE && USE_INSTANCING\n  varying mediump vec4 v_reflectionProbeData;\n#endif\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= SRGBToLinear(v_color.rgb);\n    baseColor.a *= v_color.a;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBiasAndProbeId.xy;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    s.reflectionProbeId = v_shadowBiasAndProbeId.z;\n  #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    s.reflectionProbeBlendId = v_shadowBiasAndProbeId.w;\n    #if USE_INSTANCING\n      s.reflectionProbeBlendFactor = v_reflectionProbeData.x;\n    #else\n      s.reflectionProbeBlendFactor = cc_reflectionProbeBlendData1.w;\n    #endif\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * (v_tangent.w > 0.0 ? 1.0 : -1.0);\n    s.normal =\n      (nmmp.x * emissiveScaleParam.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleParam.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_USE_LIGHTMAP && !CC_FORWARD_ADD\n    SampleAndDecodeLightMapColor(s.lightmap.rgb, s.lightmap.a, s.lightmap_test, cc_lightingMap, v_luv.xy, v_luv.z, s.normal);\n  #endif\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    packHighpData(s.position, s.position_fract_part, v_position);\n    #else\n    s.position = v_position;\n    #endif\n  vec4 pbr = pbrParams;\n  pbr.x = 1.0;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x = mix(1.0, res.r, pbrParams.x);\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n    pbr.w *= res.a;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x = mix(1.0, texture2D(occlusionMap, PBR_UV).r, pbrParams.x);\n  #endif\n  s.occlusion = pbr.x;\n  s.roughness = pbr.y;\n  s.metallic = pbr.z;\n  s.specularIntensity = pbr.w;\n  s.emissive = emissive.rgb;\n  #if USE_EMISSIVE_MAP\n    s.emissive = SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n  s.emissive *= emissiveScaleParam.xyz;\n}\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  float GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n    vec3 v = vec3(0.0);\n    vec3 up = cross(right, lookAt);\n    worldPos -= lightPos;\n    v.x = dot(worldPos, right);\n    v.y = dot(worldPos, up);\n    v.z = dot(worldPos, lookAt);\n    vec3 result = step(abs(v), BoundingHalfSizeVS);\n    return result.x * result.y * result.z;\n  }\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  vec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.0);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    int numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      if (i >= numLights) break;\n      vec3 SLU = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -cc_lightDir[i].xyz : cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.0);\n      float SNH = max(dot(N, SH), 0.0);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      float illum = 1.0;\n      float att = 1.0;\n      if (IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n        att = GetOutOfRange(position, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n      } else {\n        float distSqr = dot(SLU, SLU);\n        float litRadius = cc_lightSizeRangeAngle[i].x;\n        float litRadiusSqr = litRadius * litRadius;\n        illum = (IS_POINT_LIGHT(cc_lightPos[i].w) || IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) ? 1.0 : litRadiusSqr / max(litRadiusSqr, distSqr);\n        float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n        attRadiusSqrInv *= attRadiusSqrInv;\n        att = GetDistAtt(distSqr, attRadiusSqrInv);\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n          float cosOuter = cc_lightSizeRangeAngle[i].z;\n          float strength = clamp(cc_lightBoundingSizeVS[i].w, 0.0, 1.0);\n          float litAngleScale = 1.0 / max(0.001, mix(cosInner, 1.0, strength) - cosOuter);\n          float litAngleOffset = -cosOuter * litAngleScale;\n          att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n        }\n      }\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW  && CC_SHADOW_TYPE == 2\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w) && cc_lightSizeRangeAngle[i].w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      finalColor += SNL * cc_lightColor[i].rgb * shadow * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n  readonly buffer b_ccLightsBuffer { vec4 b_ccLights[]; };\n  readonly buffer b_clusterLightIndicesBuffer { uint b_clusterLightIndices[]; };\n  readonly buffer b_clusterLightGridBuffer { uvec4 b_clusterLightGrid[]; };\n  struct CCLight\n  {\n    vec4 cc_lightPos;\n    vec4 cc_lightColor;\n    vec4 cc_lightSizeRangeAngle;\n    vec4 cc_lightDir;\n    vec4 cc_lightBoundingSizeVS;\n  };\n  struct Cluster\n  {\n    vec3 minBounds;\n    vec3 maxBounds;\n  };\n  struct LightGrid\n  {\n    uint offset;\n    uint ccLights;\n  };\n  CCLight getCCLight(uint i)\n  {\n    CCLight light;\n    light.cc_lightPos = b_ccLights[5u * i + 0u];\n    light.cc_lightColor = b_ccLights[5u * i + 1u];\n    light.cc_lightSizeRangeAngle = b_ccLights[5u * i + 2u];\n    light.cc_lightDir = b_ccLights[5u * i + 3u];\n    light.cc_lightBoundingSizeVS = b_ccLights[5u * i + 4u];\n    return light;\n  }\n  LightGrid getLightGrid(uint cluster)\n  {\n    uvec4 gridvec = b_clusterLightGrid[cluster];\n    LightGrid grid;\n    grid.offset = gridvec.x;\n    grid.ccLights = gridvec.y;\n    return grid;\n  }\n  uint getGridLightIndex(uint start, uint offset)\n  {\n    return b_clusterLightIndices[start + offset];\n  }\n  uint getClusterZIndex(vec4 worldPos)\n  {\n    float scale = float(24u) / log(cc_nearFar.y / cc_nearFar.x);\n    float bias = -(float(24u) * log(cc_nearFar.x) / log(cc_nearFar.y / cc_nearFar.x));\n    float eyeDepth = -(cc_matView * worldPos).z;\n    uint zIndex = uint(max(log(eyeDepth) * scale + bias, 0.0));\n    return zIndex;\n  }\n  uint getClusterIndex(vec4 fragCoord, vec4 worldPos)\n  {\n    uint zIndex = getClusterZIndex(worldPos);\n    float clusterSizeX = ceil(cc_viewPort.z / float(16u));\n    float clusterSizeY = ceil(cc_viewPort.w / float(8u));\n    uvec3 indices = uvec3(uvec2(fragCoord.xy / vec2(clusterSizeX, clusterSizeY)), zIndex);\n    uint cluster = (16u * 8u) * indices.z + 16u * indices.y + indices.x;\n    return cluster;\n  }\n  vec4 CCClusterShadingAdditive (StandardSurface s, vec4 shadowPos) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / PI;\n    vec3 position;\n      #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n      position = unpackHighpData(s.position, s.position_fract_part);\n      #else\n      position = s.position;\n      #endif\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    uint cluster = getClusterIndex(gl_FragCoord, vec4(position, 1.0));\n    LightGrid grid = getLightGrid(cluster);\n    uint numLights = grid.ccLights;\n    for (uint i = 0u; i < 200u; i++) {\n      if (i >= numLights) break;\n      uint lightIndex = getGridLightIndex(grid.offset, i);\n      CCLight light = getCCLight(lightIndex);\n      vec3 SLU = light.cc_lightPos.xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = light.cc_lightSizeRangeAngle.x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(light.cc_lightSizeRangeAngle.y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (IS_SPOT_LIGHT(light.cc_lightPos.w)) {\n        float cosInner = max(dot(-light.cc_lightDir.xyz, SL), 0.01);\n        float cosOuter = light.cc_lightSizeRangeAngle.z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -light.cc_lightDir.xyz, litAngleScale, litAngleOffset);\n      }\n      vec3 lightColor = light.cc_lightColor.rgb;\n      float shadow = 1.0;\n      #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n        if (IS_SPOT_LIGHT(light.cc_lightPos.w)  && light.cc_lightSizeRangeAngle.w > 0.0) {\n          shadow = CCSpotShadowFactorBase(shadowPos, position, s.shadowBias);\n        }\n      #endif\n      lightColor *= shadow;\n      finalColor += SNL * lightColor * light.cc_lightColor.w * illum * att * (diffuseContrib + lspec);\n    }\n    return vec4(finalColor, 0.0);\n  }\n  #endif\n  void main () {\n    StandardSurface s; surf(s);\n    #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 1\n    vec4 color = CCClusterShadingAdditive(s, v_shadowPos);\n    #else\n    vec4 color = CCStandardShadingAdditive(s, v_shadowPos);\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif (CC_PIPELINE_TYPE == 0 || CC_FORCE_FORWARD_SHADING)\n  void main () {\n    StandardSurface s; surf(s);\n    vec4 color = CCStandardShadingBase(s, v_shadowPos);\n    #if CC_USE_FOG != 4\n      #if CC_USE_FLOAT_OUTPUT\n        CC_APPLY_FOG(color, s.position.xyz);\n      #elif !CC_FORWARD_ADD\n        CC_APPLY_FOG(color, s.position.xyz);\n      #endif\n    #endif\n    gl_FragData[0] = CCFragOutput(color);\n  }\n#elif CC_PIPELINE_TYPE == 1\n  vec2 signNotZero(vec2 v) {\n    return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n  }\n  vec2 float32x3_to_oct(in vec3 v) {\n    vec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n    return (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n  }\n  void main () {\n    StandardSurface s; surf(s);\n    gl_FragData[0] = s.albedo;\n    gl_FragData[2] = vec4(float32x3_to_oct(s.normal), s.roughness, s.metallic);\n    gl_FragData[1] = vec4(s.emissive, s.occlusion);\n  }\n#endif"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_lightingMap","defines":["CC_USE_LIGHTMAP","!CC_FORWARD_ADD"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":137,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":126}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"number","range":[0,3]},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_VERTEX_COLOR","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"USE_TWOSIDE","type":"boolean"},{"name":"SAMPLE_FROM_RT","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SURFACES_ENABLE_DEBUG_VIEW","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"CC_USE_HDR","type":"boolean"},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DISABLE_DIRECTIONAL_LIGHT","type":"boolean"},{"name":"CC_IBL_CONVOLUTED","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"CC_LIGHT_MAP_VERSION","type":"number","range":[0,3]},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"NORMAL_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"PBR_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_METALLIC_ROUGHNESS_MAP","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"EMISSIVE_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]}]},{"hash":2798904605,"name":"legacy/standard|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":17,"defines":[]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"albedo","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"pbrParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleParam","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"albedoMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_ALBEDO_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\n#if HAS_SECOND_UV\n  out vec2 v_uv1;\n#endif\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_probeInfo;\n    mediump vec4 cc_debug_view_mode;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_uv;\n#if HAS_SECOND_UV\n  in vec2 v_uv1;\n#endif\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALPHA_TEST\n    #if USE_ALBEDO_MAP\n      baseColor *= texture(albedoMap, ALBEDO_UV);\n    #endif\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || CC_USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n   uniform vec4 albedo;\n   uniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_uv;\n#if HAS_SECOND_UV\n  varying vec2 v_uv1;\n#endif\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALPHA_TEST\n    #if USE_ALBEDO_MAP\n      baseColor *= texture2D(albedoMap, ALBEDO_UV);\n    #endif\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":54,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":105}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"HAS_SECOND_UV","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_ALBEDO_MAP","type":"boolean"},{"name":"ALBEDO_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r"]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]},{"hash":3680218420,"name":"legacy/standard|planar-shadow-vs:vert|planar-shadow-fs:frag","blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nvec4 CalculatePlanarShadowPos(vec3 meshWorldPos, vec3 cameraPos, vec3 lightDir, vec4 plane) {\n  vec3 P = meshWorldPos;\n  vec3 L = lightDir;\n  vec3 N = plane.xyz;\n  float d = plane.w + EPSILON_LOWP;\n  float dist = (-d - dot(P, N)) / (dot(L, N) + EPSILON_LOWP);\n  vec3 shadowPos = P + L * dist;\n  return vec4(shadowPos, dist);\n}\nvec4 CalculatePlanarShadowClipPos(vec4 shadowPos, vec3 cameraPos, mat4 matView, mat4 matProj, vec4 nearFar, float bias) {\n  vec4 camPos = matView * vec4(shadowPos.xyz, 1.0);\n  float lerpCoef = saturate((nearFar.z < 0.0 ? -camPos.z : camPos.z) / (nearFar.y - nearFar.x));\n  camPos.z += mix(nearFar.x * 0.01, nearFar.y * EPSILON_LOWP * bias, lerpCoef);\n  return matProj * camPos;\n}\nout float v_dist;\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec3 worldPos = (matWorld * position).xyz;\n  vec4 shadowPos = CalculatePlanarShadowPos(worldPos, cc_cameraPos.xyz, cc_mainLitDir.xyz, cc_planarNDInfo);\n  position = CalculatePlanarShadowClipPos(shadowPos, cc_cameraPos.xyz, cc_matView, cc_matProj, cc_nearFar, cc_shadowWHPBInfo.w);\n  v_dist = shadowPos.w;\n  return position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin float v_dist;\nvec4 frag () {\n  if(v_dist < 0.0)\n    discard;\n  return CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_nearFar;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_planarNDInfo;\nvec4 CalculatePlanarShadowPos(vec3 meshWorldPos, vec3 cameraPos, vec3 lightDir, vec4 plane) {\n  vec3 P = meshWorldPos;\n  vec3 L = lightDir;\n  vec3 N = plane.xyz;\n  float d = plane.w + EPSILON_LOWP;\n  float dist = (-d - dot(P, N)) / (dot(L, N) + EPSILON_LOWP);\n  vec3 shadowPos = P + L * dist;\n  return vec4(shadowPos, dist);\n}\nvec4 CalculatePlanarShadowClipPos(vec4 shadowPos, vec3 cameraPos, mat4 matView, mat4 matProj, vec4 nearFar, float bias) {\n  vec4 camPos = matView * vec4(shadowPos.xyz, 1.0);\n  float lerpCoef = saturate((nearFar.z < 0.0 ? -camPos.z : camPos.z) / (nearFar.y - nearFar.x));\n  camPos.z += mix(nearFar.x * 0.01, nearFar.y * EPSILON_LOWP * bias, lerpCoef);\n  return matProj * camPos;\n}\nvarying float v_dist;\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec3 worldPos = (matWorld * position).xyz;\n  vec4 shadowPos = CalculatePlanarShadowPos(worldPos, cc_cameraPos.xyz, cc_mainLitDir.xyz, cc_planarNDInfo);\n  position = CalculatePlanarShadowClipPos(shadowPos, cc_cameraPos.xyz, cc_matView, cc_matProj, cc_nearFar, cc_shadowWHPBInfo.w);\n  v_dist = shadowPos.w;\n  return position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform lowp vec4 cc_shadowColor;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying float v_dist;\nvec4 frag () {\n  if(v_dist < 0.0)\n    discard;\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":90,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":58}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"}]}],[{"name":"opaque","passes":[{"program":"legacy/standard|standard-vs|standard-fs","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[0],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.5],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[0,0.5,0,0.5]},"emissiveScaleParam":{"type":16,"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"forward-add","propertyIndex":0,"program":"legacy/standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"legacy/standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"planar-shadow","propertyIndex":0,"program":"legacy/standard|planar-shadow-vs:vert|planar-shadow-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false,"stencilTestFront":true,"stencilFuncFront":5,"stencilPassOpFront":2,"stencilRefBack":128,"stencilRefFront":128,"stencilReadMaskBack":128,"stencilReadMaskFront":128,"stencilWriteMaskBack":128,"stencilWriteMaskFront":128}},{"pass":"gbuffer","phase":"gbuffer","propertyIndex":0,"program":"legacy/standard|standard-vs|standard-fs","embeddedMacros":{"CC_PIPELINE_TYPE":1}}]},{"name":"transparent","passes":[{"program":"legacy/standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"occlusion":{"type":13,"value":[0],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.5],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"handleInfo":["pbrParams",2,13]},"specularIntensity":{"type":13,"value":[0.5],"handleInfo":["pbrParams",3,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleParam",0,15]},"normalStrength":{"type":13,"value":[1],"handleInfo":["emissiveScaleParam",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"normalMap":{"value":"normal","type":28},"pbrMap":{"value":"grey","type":28},"metallicRoughnessMap":{"value":"grey","type":28},"occlusionMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"pbrParams":{"type":16,"value":[0,0.5,0,0.5]},"emissiveScaleParam":{"type":16,"value":[1,1,1,1]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"forward-add","propertyIndex":0,"program":"legacy/standard|standard-vs|standard-fs","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false}},{"phase":"shadow-caster","propertyIndex":0,"program":"legacy/standard|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1],"handleInfo":["albedo",0,16]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["albedoScaleAndCutoff",3,13]},"mainTexture":{"value":"grey","type":28,"handleInfo":["albedoMap",0,28]},"albedo":{"type":16,"value":[1,1,1,1]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"albedoMap":{"type":28,"value":"grey"}}},{"phase":"planar-shadow","propertyIndex":0,"program":"legacy/standard|planar-shadow-vs:vert|planar-shadow-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false,"stencilTestFront":true,"stencilFuncFront":5,"stencilPassOpFront":2,"stencilRefBack":128,"stencilRefFront":128,"stencilReadMaskBack":128,"stencilReadMaskFront":128,"stencilWriteMaskBack":128,"stencilWriteMaskFront":128}},{"phase":"deferred-forward","propertyIndex":0,"program":"legacy/standard|standard-vs|standard-fs","embeddedMacros":{"CC_PIPELINE_TYPE":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false}}]}]]],0,0,[],[],[]],[[{"base":"2,2,0,0,2,1","rgbe":false,"mipmaps":[{"front":"5a8gG1WVFOLKgfrEqtkTLL@b47c0@e9a6d","back":"5a8gG1WVFOLKgfrEqtkTLL@b47c0@40c10","left":"5a8gG1WVFOLKgfrEqtkTLL@b47c0@8fd34","right":"5a8gG1WVFOLKgfrEqtkTLL@b47c0@74afd","top":"5a8gG1WVFOLKgfrEqtkTLL@b47c0@bb97f","bottom":"5a8gG1WVFOLKgfrEqtkTLL@b47c0@7d38f"}]}],[6],0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[[21,"grassGoup"],[26,"grassGoup",[-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13],[0,"e5Peksu5tL9peMeABb8/JC",null,null,null,-1,0]],[27,"grass",1,[-15],[[18,true,-14,[4,"11JgtTUn5OJKE3LJ8pTj/2"],[3],4]],[0,"87M1Av0v5LhZ3LsJOTzwr3",null,null,null,1,0],[1,-0.852,0.892,-1.49],[1,1.8,1.8,1.8]],[10,"RootNode",2,[-16,-17,-18],[0,"54SHCY049LyqH1HRGY3ZVR",null,null,null,1,0]],[13,"grass",1,[-20],[[18,true,-19,[4,"abXR2STONCQrmlGd7QjDWb"],[8],9]],[0,"8avX4W7ZtLOLCZ8n5QtiPm",null,null,null,1,0],[1,1.271,0.836,-2.68],[3,0,-0.09886819763876702,0,0.9951005373808527],[1,1.4,1.4,1.4],[1,0,-11.348,0]],[10,"RootNode",4,[-21,-22,-23],[0,"bdiB2XMldLgpbPP0u9vyiH",null,null,null,1,0]],[13,"grass",1,[-25],[[14,"grass<SkeletalAnimation>",true,-24,[4,"3eRlu7+XFMf4IKjhzVuyYo"],[13],14]],[0,"5fAmHUz0xO9YFym/gsZawP",null,null,null,1,0],[1,0.816,0.874,-2.029],[3,0.009594606467145706,-0.09840154486124139,-0.09656895017241425,0.9904037143297977],[1,1.8,1.8,1.8],[1,0,-11.348,-11.138]],[10,"RootNode",6,[-26,-27,-28],[0,"0cYonIu91LHamoapMUydbc",null,null,null,1,0]],[13,"grass",1,[-30],[[14,"grass<SkeletalAnimation>",true,-29,[4,"22rvun9aNNBbAK//dWXzkX"],[18],19]],[0,"9bIVhdYYpFl7JZmL4oubNS",null,null,null,1,0],[1,1.505,0.835,-2.352],[3,0.009051343059323664,0.011005731118140823,-0.042668681053864996,0.9989876529409666],[1,1.8,1.8,1.8],[1,1.094,1.309,-4.879]],[10,"RootNode",8,[-31,-32,-33],[0,"2at9CGY1VK9qtNpM8kC/KU",null,null,null,1,0]],[13,"grass",1,[-35],[[14,"grass<SkeletalAnimation>",true,-34,[4,"0f8P8jwTVOzaIGGhmhMYJ6"],[23],24]],[0,"2d66RAsipF1brG2RGpHJY1",null,null,null,1,0],[1,2.591,0.697,-3.192],[3,-0.009569056200142995,-0.27238145223532967,-0.02174826425431747,0.961895935454317],[1,1.4,1.4,1.4],[1,-1.735,-31.653,-2.099]],[10,"RootNode",10,[-36,-37,-38],[0,"75DE0pyqBGsIOI2RSOFxap",null,null,null,1,0]],[13,"grass",1,[-40],[[14,"grass<SkeletalAnimation>",true,-39,[4,"b6LjWqcFFEYa267NpDVpBB"],[28],29]],[0,"ffwse8PqZBf4sIEkNdsA+i",null,null,null,1,0],[1,-2.85,0.766,-2.616],[3,-0.007707220961668685,-0.0985673335815995,0.07757256533280044,0.9920723646001587],[1,1.8,1.8,1.8],[1,0,-11.348,8.942]],[10,"RootNode",12,[-41,-42,-43],[0,"12tzV7tYdKJJxbVmqiEpry",null,null,null,1,0]],[13,"grass",1,[-45],[[14,"grass<SkeletalAnimation>",true,-44,[4,"a5eATDuwJGuL6l09vX0n3S"],[33],34]],[0,"adNP+ELEhC4awfcKkY8jYJ",null,null,null,1,0],[1,-3.252,0.663,-3.355],[3,-0.005303598000440666,-0.09872584440048117,0.053380291603709065,0.9936677633716235],[1,1.6,1.6,1.6],[1,9.996766443584073e-17,-11.348,6.150000000000002]],[10,"RootNode",14,[-46,-47,-48],[0,"0eVA3+ezRBf4EQOOoMIo4S",null,null,null,1,0]],[13,"grass",1,[-50],[[14,"grass<SkeletalAnimation>",true,-49,[4,"8fKHzMP19M76liKGOWy5fp"],[38],39]],[0,"33gYFxG8dO2r8iKjzjEx4z",null,null,null,1,0],[1,-4.716,0.534,-2.539],[3,-0.011417842217574529,0.10201162854238845,0.09441482697624534,0.9902267926936081],[1,1.2999999999999998,1.3,1.3],[1,-2.442,11.991,10.641]],[10,"RootNode",16,[-51,-52,-53],[0,"53OGGCuwFNs4KQ0nQRdow5",null,null,null,1,0]],[13,"grass",1,[-55],[[14,"grass<SkeletalAnimation>",true,-54,[4,"63dAWSpBBOqo5RjIXi5sEW"],[43],44]],[0,"27mCip0lFNkL+6Dj/Bpwj4",null,null,null,1,0],[1,-3.151,0.706,-2.905],[3,-0.01606605470413201,0.10576273729137807,0.0511818299419083,0.9929433748057723],[1,1.6,1.6,1.6],[1,-2.461,12.281,5.638]],[10,"RootNode",18,[-56,-57,-58],[0,"560/1xR41BPKG+lcc5935I",null,null,null,1,0]],[13,"grass",1,[-60],[[14,"grass<SkeletalAnimation>",true,-59,[4,"5c8UINxBNN1bAOwYYO6ZIW"],[48],49]],[0,"50aim7sdtB2rmsHB4KRkd5",null,null,null,1,0],[1,2.179,0.714,-3.159],[3,0.0002046174412504865,-0.2725489284000769,-0.05622568582446521,0.9604976376926917],[1,1.4,1.4,1.4],[1,-1.744,-31.778,-6.207]],[10,"RootNode",20,[-61,-62,-63],[0,"25mf8t9bhJIo3E0lcGCo1H",null,null,null,1,0]],[13,"grass",1,[-65],[[14,"grass<SkeletalAnimation>",true,-64,[4,"2dbXeRDsVAWK67o3tGgUEl"],[53],54]],[0,"70DWXrCRRL4pWATtzgi7DN",null,null,null,1,0],[1,5.041,0.406,-3.58],[3,0.026333680128465056,-0.27127042474669716,-0.14805365417229147,0.9506834433368816],[1,1.4,1.4,1.4],[1,-1.815,-32.126,-17.205]],[10,"RootNode",22,[-66,-67,-68],[0,"9dXaYb8ytBBb2yYH4yN6Vh",null,null,null,1,0]],[13,"grass",1,[-70],[[14,"grass<SkeletalAnimation>",true,-69,[4,"42733HPMdIEqobiaBVXbRJ"],[58],59]],[0,"7aOtJ3fThN27Zj4fmkg0ut",null,null,null,1,0],[1,4.153,0.548,-3.566],[3,0.01263456693718553,-0.27225485806840527,-0.09997674733537244,0.9569338064718487],[1,1.4,1.4,1.4],[1,-1.769,-31.94,-11.433]],[10,"RootNode",24,[-71,-72,-73],[0,"fa4L3FVuFMwYhNq67HoU7c",null,null,null,1,0]],[8,"grass",3,[[9,-74,[4,"a6J1jU/r1BPKNIcVMEREit"],[0],[2],2,1,2]],[0,"5fs1r6h0xEiJFeWVPk8SNl",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",3,[-75],[0,"daWdShf/9NHLgm8BB+DJZm",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",27,[[5,"Bone003",-76,[0,"8e/dPEvbdIMo48q55vpZZ3",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"beKna0bXZNtrHWMkpFZoVU",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",3,[-77],[0,"94aP4+w7dE/qUrh7Cfcv3Y",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",29,[[5,"Bone006",-78,[0,"96ATlvvpZKqpZWVYxnyW6U",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"8fu8biB4BPFKtDBKsYv4K/",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",5,[[9,-79,[4,"28WH2cvhNDFbN3it+8Q+XK"],[5],[2],4,6,7]],[0,"74Q+wg/aVBj5Bkvd+Cqz4L",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",5,[-80],[0,"4fGc2baulLjbJeePpPYcqt",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",32,[[5,"Bone003",-81,[0,"af9wSIs/ZHx5FXOjfa1Jum",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"25LOOT8GBDpr0h1KIC5gCx",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",5,[-82],[0,"b8DSzxi5tJyKiMnjvG0NLg",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",34,[[5,"Bone006",-83,[0,"65QAhjUVBAtLwEci9t05Ey",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"e75gT5ogJMOoh/2sggS7OQ",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",7,[[9,-84,[4,"87exLhmM1P35jx6GLN7j5f"],[10],[2],6,11,12]],[0,"60njdFxDhJWowG9HZr9kRy",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",7,[-85],[0,"dfSzBMugdCkL5lyChYPcpt",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",37,[[5,"Bone003",-86,[0,"91jR835RZHKbRhzSn1x2pJ",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"3bw6IJ5hBJ0aqjcninjsA3",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",7,[-87],[0,"36km6+kJtJZ4iiy8pwU3RO",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",39,[[5,"Bone006",-88,[0,"977HJ5Wy5HiapZRnYB3I8X",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"3da6ppQblGu7DGQDIjczFt",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",9,[[9,-89,[4,"dduLonFhNK+q908BUlLM7f"],[15],[2],8,16,17]],[0,"f2zxp5nX1CJq18JC2EndYO",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",9,[-90],[0,"3c+BtM6atJC4XerbYlNlM0",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",42,[[5,"Bone003",-91,[0,"baL59AVvRKlKmpQqSjNAYI",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"89NJAVd1tBZ6C0iX/YbeY2",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",9,[-92],[0,"9byDe6eNtGPIztX4VSZKlQ",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",44,[[5,"Bone006",-93,[0,"6fAgsRfRRHeoZrCvNeGhDK",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"8exO45eF5F2KzRxFbNE1M/",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",11,[[9,-94,[4,"af0f1GeGlKf5MvKMEuH8MJ"],[20],[2],10,21,22]],[0,"a2WxB7prNBKZLuuRtE7RC2",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",11,[-95],[0,"d9cSWZZzxJ0JJz3NZ3KYKr",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",47,[[5,"Bone003",-96,[0,"65JgfqDUlBhq62ZblXl99a",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"613BOOO+hIlqnTjr1LZ7yD",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",11,[-97],[0,"daMGy+QoZIMbYWUh1/PBDR",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",49,[[5,"Bone006",-98,[0,"4bzVNkn1hF04sTb5BrBwWZ",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"aea82LsKdAiqVuBFPi2Vfz",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",13,[[9,-99,[4,"e9BPt5G81CloUmA5IJNHIQ"],[25],[2],12,26,27]],[0,"32O+zfC79Ly5/JDvR+zPy3",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",13,[-100],[0,"2csxgVNAlDEIWU7lnXQfKS",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",52,[[5,"Bone003",-101,[0,"f31n3srf1OQ6ztTn+Z0+bi",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"39pnXuaeZGe5VqFTUXoXAo",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",13,[-102],[0,"e1Z+TO4odC37Bc8FKLNniF",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",54,[[5,"Bone006",-103,[0,"c8HIUzEBxJx72ffmHr7Yzh",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"82tqRzYDNKi6iXruWWHldm",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",15,[[9,-104,[4,"7dt8ZZ5EBNDIxOgpt1XbGu"],[30],[2],14,31,32]],[0,"3c/GljN9JNKpGUQDJiCaAz",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",15,[-105],[0,"17tlC2EGZMWoKAixVNAp0A",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",57,[[5,"Bone003",-106,[0,"9fnTS8hnVIWqrzTdhgEpre",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"77DlSvZMVCFLNlyGWiwIha",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",15,[-107],[0,"d1EnMgh6RE7o+kI5cUNlG0",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",59,[[5,"Bone006",-108,[0,"8cUixi2TpMHINjSklAPeYi",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"b7XmnH2bBCVpvgTAKnVXA2",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",17,[[9,-109,[4,"c4Nekl9YtKUKupS0ASX7It"],[35],[2],16,36,37]],[0,"43yCcO1I5D6qP+LJIIGKjX",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",17,[-110],[0,"0aJTcuk/5M56nEkb+D7tN9",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",62,[[5,"Bone003",-111,[0,"d5T2sohQVAEa4ljoSzlMKU",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"93hV+qqgFP44pIvuByy6RE",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",17,[-112],[0,"6etpava3ZGlovr3HG7SpRo",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",64,[[5,"Bone006",-113,[0,"6c2sTe+khLGYrsZVSADL4H",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"ecsSU+lvpNf7DhOOeFG7w2",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",19,[[9,-114,[4,"b9cuhcVRxPvZTPHcAyE7eS"],[40],[2],18,41,42]],[0,"87cW2HzEtNk4+RMW95NbLB",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",19,[-115],[0,"16ssZzbLdO76GQg4Dvdp/y",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",67,[[5,"Bone003",-116,[0,"5bcVkwfGRPza49BU4T6rqn",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"fcqb+cLDVJ3KNvBTyJYBwm",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",19,[-117],[0,"0eRKfLOh9OdLsOOjTosv1c",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",69,[[5,"Bone006",-118,[0,"0b/yPLcR1FiZPqyfaG8HBZ",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"0fPapM97RGmYmlB69FuuSF",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",21,[[9,-119,[4,"f3T3OFBBJBYrGbPSQ+k7GJ"],[45],[2],20,46,47]],[0,"08LJZ1ezRCiqnszI5cXQTx",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",21,[-120],[0,"c9g0zchT9L8IQmY+99TABR",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",72,[[5,"Bone003",-121,[0,"d8OdalQsZKwLFf2mFuR1VJ",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"ecFy8CTgxCib8Fky/YcoUL",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",21,[-122],[0,"91+xPZxDtGRp/x7cNrBUhM",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",74,[[5,"Bone006",-123,[0,"66R8TA3S1NT4HLywjDiP1Q",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"963dgjTmdES7q6KBvCTllJ",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",23,[[9,-124,[4,"d0A5LfhGhAfrDnBGJ3JzOe"],[50],[2],22,51,52]],[0,"203+J3Vb1LP7KUgkjLvNtX",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",23,[-125],[0,"9eOEdVVahA+rbDiF4AJNNX",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",77,[[5,"Bone003",-126,[0,"3aJII/zG9KaYapX0uizphW",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"48r+NZR1BD7Y5qEv/ruQsO",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",23,[-127],[0,"469eCD0ttKHZacZ3xtfeuD",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",79,[[5,"Bone006",-128,[0,"1fFpy0ihVOYbzhBLRLkL1Y",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"d9iCqzyppAILXebiHSqtDk",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[8,"grass",25,[[9,-129,[4,"161SEdWiFO/abXxUI8RkYk"],[55],[2],24,56,57]],[0,"80TsYKkUVBAIbPGc2Ao+X4",null,null,null,1,0],[3,0.37992816729770207,0.5963678291908521,0.5963678291908521,-0.37992816729770207],[1,0.614784121513367,0.614784121513367,0.614784121513367],[1,-90,-115.0000056286655,0]],[6,"Bone001",25,[-130],[0,"54j/6cneBCF4PpXQIO+ZrT",null,null,null,1,0],[1,-0.0461842827498913,0.0000118009265861474,-0.0284814611077309],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone002",82,[[5,"Bone003",-131,[0,"6aDs2ciZhDh6tahiNmO4QO",null,null,null,1,0],[1,0.0397140197455883,-1.19209286886246e-9,7.15255721317476e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"1er+9JvftCj5j548DE5PNk",null,null,null,1,0],[1,0.0404664427042007,-3.57627860658738e-9,0],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]],[6,"Bone004",25,[-132],[0,"c8ON8aNTZH1YV9KZsolNGO",null,null,null,1,0],[1,0.0710692703723907,0.0000118009265861474,0.0136896027252078],[3,-0.0000017283479103639154,-0.000001696768662714476,0.7049074170330618,0.7092993256770451],[1,2.53999996185303,2.53999996185303,2.53999996185303],[1,-0.0005507418826256091,0.00027320859410338513,89.64412979694991]],[3,"Bone005",84,[[5,"Bone006",-133,[0,"1eZ45FwjhMoY5AmDd/ApaW",null,null,null,1,0],[1,0.039714016020298,0,7.74860353658369e-9],[3,1.4018830392883508e-10,-1.4662893682703937e-13,-0.0010459420626472054,0.9999994530024512],[1,1.606440509162768e-8,-1.4726229276075984e-18,-0.11985615346346049]]],[0,"7fkJUsKFZMHbutZKiHcKAf",null,null,null,1,0],[1,0.0404664427042007,-4.76837147544984e-9,5.9604643443123e-10],[3,0.000002421418716486127,1.5182564735607207e-8,0.006269989150778519,0.9999803434219023],[1,0.000277479600078167,-3.18993241527229e-13,0.7184925395739944]]],0,[0,5,1,0,-1,2,0,-2,4,0,-3,6,0,-4,8,0,-5,10,0,-6,12,0,-7,14,0,-8,16,0,-9,18,0,-10,20,0,-11,22,0,-12,24,0,1,2,0,-1,3,0,-1,26,0,-2,27,0,-3,29,0,1,4,0,-1,5,0,-1,31,0,-2,32,0,-3,34,0,1,6,0,-1,7,0,-1,36,0,-2,37,0,-3,39,0,1,8,0,-1,9,0,-1,41,0,-2,42,0,-3,44,0,1,10,0,-1,11,0,-1,46,0,-2,47,0,-3,49,0,1,12,0,-1,13,0,-1,51,0,-2,52,0,-3,54,0,1,14,0,-1,15,0,-1,56,0,-2,57,0,-3,59,0,1,16,0,-1,17,0,-1,61,0,-2,62,0,-3,64,0,1,18,0,-1,19,0,-1,66,0,-2,67,0,-3,69,0,1,20,0,-1,21,0,-1,71,0,-2,72,0,-3,74,0,1,22,0,-1,23,0,-1,76,0,-2,77,0,-3,79,0,1,24,0,-1,25,0,-1,81,0,-2,82,0,-3,84,0,1,26,0,-1,28,0,0,28,0,-1,30,0,0,30,0,1,31,0,-1,33,0,0,33,0,-1,35,0,0,35,0,1,36,0,-1,38,0,0,38,0,-1,40,0,0,40,0,1,41,0,-1,43,0,0,43,0,-1,45,0,0,45,0,1,46,0,-1,48,0,0,48,0,-1,50,0,0,50,0,1,51,0,-1,53,0,0,53,0,-1,55,0,0,55,0,1,56,0,-1,58,0,0,58,0,-1,60,0,0,60,0,1,61,0,-1,63,0,0,63,0,-1,65,0,0,65,0,1,66,0,-1,68,0,0,68,0,-1,70,0,0,70,0,1,71,0,-1,73,0,0,73,0,-1,75,0,0,75,0,1,76,0,-1,78,0,0,78,0,-1,80,0,0,80,0,1,81,0,-1,83,0,0,83,0,-1,85,0,0,85,0,8,1,133],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4,-1,2,3,-1,4],[1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0,1,2,3,0,0]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["6fiRp7WghI5phB3bNkrIax"]}],[2],0,[],[],[]],[[[40,"main"],[28,0,{},[24,"6dMvPN2t1B66O9Zc3HG8dr",null,null,-1,[25,"93xtJEZ71OF5Gk8u497J9k",null,[[7,["lightmapSettings"],[1,["78XZsd31xPjIsSP2888FcN"]],[2]],[7,["lightmapSettings"],[1,["ffoVYmt2NOmIBz5DHpacF8"]],[2]],[7,["lightmapSettings"],[1,["9aCVBuMeZPv6so1VxT6c40"]],[2]],[7,["lightmapSettings"],[1,["ca1srfPsJJgKKJww9GO/JE"]],[2]]]],0]],[41,"main",[-3,-4,1,-5],[38,null,null,null,[[17,["_skinningRoot"],1,[1,["04W3Kzvb9BZbZUGFZzfzi5"]],1,[1,["6dMvPN2t1B66O9Zc3HG8dr"]]],[17,["_skinningRoot"],1,[1,["04W3Kzvb9BZbZUGFZzfzi5"]],1,[1,["6dMvPN2t1B66O9Zc3HG8dr"]]],[17,["_skinningRoot"],1,[1,["04W3Kzvb9BZbZUGFZzfzi5"]],1,[1,["6dMvPN2t1B66O9Zc3HG8dr"]]],[17,["_skinningRoot"],1,[1,["04W3Kzvb9BZbZUGFZzfzi5"]],1,[1,["6dMvPN2t1B66O9Zc3HG8dr"]]]],[1,-2]],[42,[43,0.78125,[2,0.2,0.5019607843137255,0.8,0.520833125],[2,0.2,0.5019607843137255,0.8,0.520833125]],[44,true,1,1,[4,1929379840],[0,512,512]],[45,true,2,3],[46,[4,4292993505]],[47],[48],[49],[50]]],[29,0,{},2,[24,"e5Peksu5tL9peMeABb8/JC",null,null,-6,[25,"7e4SH9jydKyaQjXZtS5AiQ",null,[[7,["lightmapSettings"],[1,["a6J1jU/r1BPKNIcVMEREit"]],[2]],[11,1,["_shadowReceivingMode"],[1,["a6J1jU/r1BPKNIcVMEREit"]]],[7,["lightmapSettings"],[1,["28WH2cvhNDFbN3it+8Q+XK"]],[2]],[11,1,["_shadowReceivingMode"],[1,["28WH2cvhNDFbN3it+8Q+XK"]]],[7,["lightmapSettings"],[1,["87exLhmM1P35jx6GLN7j5f"]],[2]],[11,1,["_shadowReceivingMode"],[1,["87exLhmM1P35jx6GLN7j5f"]]],[7,["lightmapSettings"],[1,["dduLonFhNK+q908BUlLM7f"]],[2]],[11,1,["_shadowCastingMode"],[1,["dduLonFhNK+q908BUlLM7f"]]],[11,1,["_shadowReceivingMode"],[1,["dduLonFhNK+q908BUlLM7f"]]],[7,["lightmapSettings"],[1,["af0f1GeGlKf5MvKMEuH8MJ"]],[2]],[11,1,["_shadowReceivingMode"],[1,["af0f1GeGlKf5MvKMEuH8MJ"]]],[7,["lightmapSettings"],[1,["e9BPt5G81CloUmA5IJNHIQ"]],[2]],[11,1,["_shadowReceivingMode"],[1,["e9BPt5G81CloUmA5IJNHIQ"]]],[7,["lightmapSettings"],[1,["7dt8ZZ5EBNDIxOgpt1XbGu"]],[2]],[11,1,["_shadowReceivingMode"],[1,["7dt8ZZ5EBNDIxOgpt1XbGu"]]],[7,["lightmapSettings"],[1,["c4Nekl9YtKUKupS0ASX7It"]],[2]],[11,1,["_shadowReceivingMode"],[1,["c4Nekl9YtKUKupS0ASX7It"]]],[7,["lightmapSettings"],[1,["b9cuhcVRxPvZTPHcAyE7eS"]],[2]],[11,1,["_shadowReceivingMode"],[1,["b9cuhcVRxPvZTPHcAyE7eS"]]],[7,["lightmapSettings"],[1,["f3T3OFBBJBYrGbPSQ+k7GJ"]],[2]],[11,1,["_shadowReceivingMode"],[1,["f3T3OFBBJBYrGbPSQ+k7GJ"]]],[7,["lightmapSettings"],[1,["d0A5LfhGhAfrDnBGJ3JzOe"]],[2]],[11,1,["_shadowReceivingMode"],[1,["d0A5LfhGhAfrDnBGJ3JzOe"]]],[7,["lightmapSettings"],[1,["161SEdWiFO/abXxUI8RkYk"]],[2]],[11,1,["_shadowReceivingMode"],[1,["161SEdWiFO/abXxUI8RkYk"]]]]],1]],[22,"Main Light","c0y6F5f+pAvI805TdmxIjx",2,[[51,125000,3.2552083333333335,true,2,0.01,0.45098039215686275,10,1,50,10,-7,[52]]],[1,-2.955,3.412,5.118],[3,-0.24999999999999997,-0.24999999999999997,-0.06698729810778066,0.9330127018922194],[1,-30,-30,0]],[22,"Main Camera","c9DMICJLFO5IeO07EPon7U",2,[[53,14,1820327937,-8]],[1,0.4563737338172984,4.020698998822525,7.83104356477376],[3,-0.07236081996736556,0.03501809641207027,0.002542173940871125,0.9967603433167774],[1,-8.304321541008003,4.024165472580301,9.93923337957349e-17]]],0,[0,5,1,0,-2,3,0,-1,4,0,-2,5,0,-4,3,0,5,3,0,1,4,0,1,5,0,10,2,1,0,2,8],[0,0,0,0],[9,9,11,12],[7,8,5,5]],[[[19,"soldier",[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_OUTLINE_PASS":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true,"BASE_COLOR_MAP_AS_SHADE_MAP_1":true,"BASE_COLOR_MAP_AS_SHADE_MAP_2":true},{"USE_BASE_COLOR_MAP":true}],[[{},[{},"specular",8,[4,16777215],"mainTexture",6,0],{},{}],0,11,0,0]]],0,0,[0,0],[6,7],[9,10]],[[[19,"shield",[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}},{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_ALBEDO_MAP":true},{"USE_ALBEDO_MAP":true},{"USE_ALBEDO_MAP":true}],[[[{"alphaThreshold":0,"roughness":0.70710676908493,"metallic":0.400000005960464},"mainTexture",6,0],{},{}],11,0,0]]],0,0,[0,0],[6,7],[11,12]],[[{"fmt":"1","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,0,0,0,0","mipmaps":["955bAq4zhCPL27F0htsdnr"]}],[2],0,[],[],[]],[[[20,"legacy/toon",[{"hash":2832630087,"name":"legacy/toon|legacy/main-functions/outline-vs:vert|legacy/main-functions/outline-fs:frag","blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"OutlineVert","stageFlags":1,"binding":0,"members":[{"name":"outlineParams","type":16,"count":1}],"defines":[]},{"name":"OutlineFrag","stageFlags":16,"binding":1,"members":[{"name":"baseColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nout vec2 v_uv;\nlayout(std140) uniform OutlineVert {\n  vec4 outlineParams;\n};\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  float scaleZ = cc_nearFar.z == 0.0 ? 0.5 : 1.0;\n  pos.z -= outlineParams.y * 0.002 * scaleZ;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin vec2 v_uv;\nlayout(std140) uniform OutlineFrag {\n  vec4 baseColor;\n};\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform mediump vec4 cc_nearFar;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\nvarying vec2 v_uv;\n   uniform vec4 outlineParams;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  float width = outlineParams.x * 0.001;\n  #if USE_POSITION_SCALING\n    vec3 dir = normalize(In.position.xyz);\n    float flip = dot(dir, normalize(In.normal)) < 0.0 ? -1.0 : 1.0;\n    In.position.xyz += flip * dir * width * 2.0;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #else\n    In.position.xyz += normalize(In.normal) * width;\n    vec4 pos = cc_matProj * (cc_matView * matWorld) * In.position;\n  #endif\n  float scaleZ = cc_nearFar.z == 0.0 ? 0.5 : 1.0;\n  pos.z -= outlineParams.y * 0.002 * scaleZ;\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform mediump vec4 cc_mainLitColor;\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying vec2 v_uv;\n   uniform vec4 baseColor;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvec4 frag () {\n  vec4 color = baseColor * cc_mainLitColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 texColor = texture2D(baseColorMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    color *= texColor;\n  #endif\n  return CCFragOutput(vec4(color.rgb, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":75,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":43}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"USE_POSITION_SCALING","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC","type":"boolean"},{"name":"CC_SURFACES_ENABLE_DEBUG_VIEW","type":"boolean"},{"name":"USE_BASE_COLOR_MAP","type":"boolean"}]},{"hash":2664574374,"name":"legacy/toon|toon-vs:vert|toon-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_BASE_COLOR_MAP"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":2,"defines":["USE_NORMAL_MAP"]},{"name":"shadeMap1","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":["USE_1ST_SHADE_MAP"]},{"name":"shadeMap2","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":["USE_2ND_SHADE_MAP"]},{"name":"specularMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":["USE_SPECULAR_MAP"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":6,"defines":["USE_EMISSIVE_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBiasAndProbeId.x + cc_shadowWHPBInfo.w, a_localShadowBiasAndProbeId.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\nout vec3 v_position;\nout vec2 v_uv;\nout mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  out mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  out mediump vec4 v_tangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n  float shadowCover;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n    vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n  };\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  float GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n    vec3 v = vec3(0.0);\n    vec3 up = cross(right, lookAt);\n    worldPos -= lightPos;\n    v.x = dot(worldPos, right);\n    v.y = dot(worldPos, up);\n    v.z = dot(worldPos, lookAt);\n    vec3 result = step(abs(v), BoundingHalfSizeVS);\n    return result.x * result.y * result.z;\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -cc_lightDir[i].xyz : cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      float illum = 1.0;\n      float att = 1.0;\n      if (IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n        att = GetOutOfRange(position, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n      } else {\n        float distSqr = dot(SLU, SLU);\n        float litRadius = cc_lightSizeRangeAngle[i].x;\n        float litRadiusSqr = litRadius * litRadius;\n        illum = (IS_POINT_LIGHT(cc_lightPos[i].w) || IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) ? 1.0 : litRadiusSqr / max(litRadiusSqr , distSqr);\n        float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n        attRadiusSqrInv *= attRadiusSqrInv;\n        att = GetDistAtt(distSqr, attRadiusSqrInv);\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n          float cosOuter = cc_lightSizeRangeAngle[i].z;\n          float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n          float litAngleOffset = -cosOuter * litAngleScale;\n          att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n        }\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    in highp vec4 v_shadowPos;\n    layout(std140) uniform CCShadow {\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      highp vec4 cc_shadowInvProjDepthInfo;\n      highp vec4 cc_shadowProjDepthInfo;\n      highp vec4 cc_shadowProjInfo;\n      mediump vec4 cc_shadowNFLSInfo;\n      mediump vec4 cc_shadowWHPBInfo;\n      mediump vec4 cc_shadowLPNNInfo;\n      lowp vec4 cc_shadowColor;\n      mediump vec4 cc_planarNDInfo;\n    };\n    #if CC_SUPPORT_CASCADED_SHADOW_MAP\n      layout(std140) uniform CCCSM {\n        highp vec4 cc_csmViewDir0[4];\n        highp vec4 cc_csmViewDir1[4];\n        highp vec4 cc_csmViewDir2[4];\n        highp vec4 cc_csmAtlas[4];\n        highp mat4 cc_matCSMViewProj[4];\n        highp vec4 cc_csmProjDepthInfo[4];\n        highp vec4 cc_csmProjInfo[4];\n        highp vec4 cc_csmSplitsInfo;\n      };\n    #endif\n    #if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n    #define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n    #else\n    #define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n    #endif\n    #if CC_RECEIVE_SHADOW\n      uniform highp sampler2D cc_shadowMap;\n      uniform highp sampler2D cc_spotShadowMap;\n      vec4 shadowTexure(highp sampler2D shadowMap, vec2 coord) {\n          #if defined(CC_USE_WGPU)\n              return textureLod(shadowMap, coord, 0.0);\n          #else\n            return texture(shadowMap, coord);\n          #endif\n      }\n      float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        #if CC_SHADOWMAP_FORMAT == 1\n          return step(shadowNDCPos.z, dot(shadowTexure(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          return step(shadowNDCPos.z, shadowTexure(shadowMap, shadowNDCPos.xy).x);\n        #endif\n      }\n      float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        vec2 oneTap = 1.0 / shadowMapResolution;\n        vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n        float block0, block1, block2, block3;\n        #if CC_SHADOWMAP_FORMAT == 1\n          block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n          block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n          block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n          block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n        #endif\n        float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block2, block3, coefX);\n        float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n        return mix(resultX, resultY, coefY);\n      }\n      float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        vec2 oneTap = 1.0 / shadowMapResolution;\n        float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n        float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n        float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n        float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n        float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n        #if CC_SHADOWMAP_FORMAT == 1\n          block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n          block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n          block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n          block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n          block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n          block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n          block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n          block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n          block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n        #endif\n        float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n        float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n        float shadow = 0.0;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block3, block4, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block1, block2, coefX);\n        resultY = mix(block4, block5, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block3, block4, coefX);\n        resultY = mix(block6, block7, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        resultX = mix(block4, block5, coefX);\n        resultY = mix(block7, block8, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        return shadow * 0.25;\n      }\n      float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        vec2 oneTap = 1.0 / shadowMapResolution;\n        vec2 twoTap = oneTap * 2.0;\n        vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n        vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n        vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n        vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n        vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n        vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n        vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n        vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n        vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n        vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n        vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n        vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n        vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n        vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n        vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n        vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n        vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n        vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n        vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n        vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n        vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n        vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n        vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n        vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n        vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n        float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n        #if CC_SHADOWMAP_FORMAT == 1\n          block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block9 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block10 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block11 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block12 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block13 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block14 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block15 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block16 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block17 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block18 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block19 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block20 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block21 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block22 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block23 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block24 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block25 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset1).x);\n          block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset2).x);\n          block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset3).x);\n          block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset4).x);\n          block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset5).x);\n          block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset6).x);\n          block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset7).x);\n          block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset8).x);\n          block9 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset9).x);\n          block10 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset10).x);\n          block11 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset11).x);\n          block12 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset12).x);\n          block13 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset13).x);\n          block14 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset14).x);\n          block15 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset15).x);\n          block16 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset16).x);\n          block17 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset17).x);\n          block18 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset18).x);\n          block19 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset19).x);\n          block20 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset20).x);\n          block21 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset21).x);\n          block22 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset22).x);\n          block23 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset23).x);\n          block24 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset24).x);\n          block25 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset25).x);\n        #endif\n        vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n        vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n        vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n        vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n        vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n        float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n        vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n        vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n        vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n        vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n        float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n        vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n        vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n        vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n        vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n        float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n        vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n        vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n        vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n        vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n        float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n        float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n        return fAvg;\n      }\n      bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n      {\n      \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n      \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n      \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n      \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n      \t\treturn false;\n      \t}\n      \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n      \treturn true;\n      }\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n      {\n        vec4 newShadowPos = shadowPos;\n        if (normalBias > EPSILON_LOWP)\n        {\n          vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n          if (viewNormal.z < 0.1)\n            newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n        }\n        return newShadowPos;\n      }\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n      {\n      \tvec4 newShadowPos = shadowPos;\n      \tif (normalBias > EPSILON_LOWP)\n      \t{\n      \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n      \t\tif (viewNormal.z < 0.1)\n      \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      \t}\n      \treturn newShadowPos;\n      }\n      float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n      {\n      \treturn (NDCDepth - projBiasZ) / projScaleZ;\n      }\n      vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n      {\n      \tfloat coeffA = projScaleZ;\n      \tfloat coeffB = projBiasZ;\n      \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n      \tviewSpacePos_z += viewspaceDepthBias;\n      \tvec4 result = shadowPos;\n      \tresult.z = viewSpacePos_z * coeffA + coeffB;\n      \treturn result;\n      }\n      float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n        pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n        float realtimeShadow = 1.0;\n        #if CC_DIR_SHADOW_PCF_TYPE == 3\n          realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n        #endif\n        #if CC_DIR_SHADOW_PCF_TYPE == 2\n          realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n        #endif\n        #if CC_DIR_SHADOW_PCF_TYPE == 1\n          realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n        #endif\n        #if CC_DIR_SHADOW_PCF_TYPE == 0\n          realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n        #endif\n        shadowPosWithDepthBias = pos;\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n      #if CC_SUPPORT_CASCADED_SHADOW_MAP\n        bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n          highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n          highp float minRange = cc_csmSplitsInfo.x;\n          highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n          ratio = 0.0;\n          if (clipPos.x <= minRange) {\n            ratio = clipPos.x * thresholdInvert;\n            return true;\n          }\n          if (clipPos.x >= maxRange) {\n            ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n            return true;\n          }\n          if (clipPos.y <= minRange) {\n            ratio = clipPos.y  * thresholdInvert;\n            return true;\n          }\n          if (clipPos.y >= maxRange) {\n            ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n            return true;\n          }\n          return false;\n        }\n        bool CCHasCSMLevel(int level, vec3 worldPos) {\n          highp float layerThreshold = cc_csmViewDir0[0].w;\n          bool hasLevel = false;\n          for (int i = 0; i < 4; i++) {\n            if (i == level) {\n              vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n              vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n              if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n                  clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n                  clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n                hasLevel = true;\n              }\n            }\n          }\n          return hasLevel;\n        }\n        void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n          highp float layerThreshold = cc_csmViewDir0[0].w;\n          for (int i = 0; i < 4; i++) {\n            vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n            vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n            if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n                clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n                clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n              csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n              csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n              shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n              shadowProjInfo = cc_csmProjInfo[i];\n              shadowViewDir0 = cc_csmViewDir0[i].xyz;\n              shadowViewDir1 = cc_csmViewDir1[i].xyz;\n              shadowViewDir2 = cc_csmViewDir2[i].xyz;\n            }\n          }\n        }\n        int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n        {\n          int level = -1;\n          highp float layerThreshold = cc_csmViewDir0[0].w;\n          for (int i = 0; i < 4; i++) {\n            vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n            vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n            if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n                clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n                clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n              #if CC_CASCADED_LAYERS_TRANSITION\n                isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n              #endif\n              csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n              csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n              shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n              shadowProjInfo = cc_csmProjInfo[i];\n              shadowViewDir0 = cc_csmViewDir0[i].xyz;\n              shadowViewDir1 = cc_csmViewDir1[i].xyz;\n              shadowViewDir2 = cc_csmViewDir2[i].xyz;\n              level = i;\n            }\n          }\n          return level;\n        }\n        int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n        {\n          bool isTransitionArea = false;\n          highp float transitionRatio = 0.0;\n          return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n        }\n        float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n        {\n          bool isTransitionArea = false;\n          highp float ratio = 0.0;\n          csmPos = vec4(1.0);\n          vec4 shadowProjDepthInfo, shadowProjInfo;\n          vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n          int level = -1;\n          #if CC_CASCADED_LAYERS_TRANSITION\n            level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n          #else\n            level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n          #endif\n          if (level < 0) { return 1.0; }\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n          pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          csmPosWithBias = pos;\n          float realtimeShadow = 1.0;\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n          #endif\n          #if CC_CASCADED_LAYERS_TRANSITION\n            vec4 nextCSMPos = vec4(1.0);\n            vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n            vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n            float nextRealtimeShadow = 1.0;\n            CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n            bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n            if (hasNextLevel && isTransitionArea) {\n              vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n              nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n              #if CC_DIR_SHADOW_PCF_TYPE == 3\n                nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n              #endif\n              #if CC_DIR_SHADOW_PCF_TYPE == 2\n                nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n              #endif\n              #if CC_DIR_SHADOW_PCF_TYPE == 1\n                nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n              #endif\n              #if CC_DIR_SHADOW_PCF_TYPE == 0\n                nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n              #endif\n              return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n            }\n            return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n          #else\n            return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n          #endif\n        }\n      #else\n        int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n          return -1;\n        }\n        float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n          csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n          return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n        }\n      #endif\n      float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n        vec4 shadowPosWithDepthBias;\n        return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n      }\n      float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n        vec4 csmPos, csmPosWithBias;\n        return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n      }\n    #endif\n        #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight + EPSILON_LOWP, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 dirlightContrib = diffuse + specular;\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if(s.shadowCover < NL && cc_mainLitDir.w > 0.0) {\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      #endif\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n        shadow = CCShadowFactorBase(v_shadowPos, N, s.shadowBias);\n      #endif\n    }\n    #endif\n    dirlightContrib *= shadow;\n    vec3 finalColor = lightColor * dirlightContrib;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nin vec3 v_position;\nin vec2 v_uv;\n#if CC_RECEIVE_SHADOW\n  in mediump vec2 v_shadowBias;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nin mediump vec3 v_normal;\n#if USE_NORMAL_MAP\n  in mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 localBaseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    localBaseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = localBaseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * (v_tangent.w > 0.0 ? 1.0 : -1.0);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n  s.shadowCover = miscParams.x;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n  uniform highp vec4 cc_localShadowBias;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\nvec2 CCGetShadowBias()\n{\n  #if USE_INSTANCING\n    return vec2(a_localShadowBiasAndProbeId.x + cc_shadowWHPBInfo.w, a_localShadowBiasAndProbeId.y + cc_shadowLPNNInfo.z);\n  #else\n    return vec2(cc_localShadowBias.x + cc_shadowWHPBInfo.w, cc_localShadowBias.y + cc_shadowLPNNInfo.z);\n  #endif\n}\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying mediump vec3 v_normal;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if CC_RECEIVE_SHADOW\n    v_shadowBias = CCGetShadowBias();\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  #if USE_NORMAL_MAP\n    v_tangent.xyz = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_tangent.w = In.tangent.w;\n  #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nhighp float unpackHighpData (float mainPart, float modPart) {\n  highp float data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp float unpackHighpData (float mainPart, float modPart, const float modValue) {\n  highp float data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out float mainPart, out float modPart, highp float data, const float modValue) {\n  highp float divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart) {\n  highp vec2 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec2 unpackHighpData (vec2 mainPart, vec2 modPart, const float modValue) {\n  highp vec2 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec2 mainPart, out vec2 modPart, highp vec2 data, const float modValue) {\n  highp vec2 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart) {\n  highp vec3 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec3 unpackHighpData (vec3 mainPart, vec3 modPart, const float modValue) {\n  highp vec3 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec3 mainPart, out vec3 modPart, highp vec3 data, const float modValue) {\n  highp vec3 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart) {\n  highp vec4 data = mainPart;\n  return data + modPart;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data) {\n  mainPart = fract(data);\n  modPart = data - mainPart;\n}\nhighp vec4 unpackHighpData (vec4 mainPart, vec4 modPart, const float modValue) {\n  highp vec4 data = mainPart * modValue;\n  return data + modPart * modValue;\n}\nvoid packHighpData (out vec4 mainPart, out vec4 modPart, highp vec4 data, const float modValue) {\n  highp vec4 divide = data / modValue;\n  mainPart = floor(divide);\n  modPart = (data - mainPart * modValue) / modValue;\n}\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  vec3 position, position_fract_part;\n  #else\n  vec3 position;\n  #endif\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n  float shadowCover;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n    #define LIGHTS_PER_PASS 1\n  #else\n    #define LIGHTS_PER_PASS 10\n  #endif\n  #if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightBoundingSizeVS[LIGHTS_PER_PASS];\n  #endif\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  float GetOutOfRange (vec3 worldPos, vec3 lightPos, vec3 lookAt, vec3 right, vec3 BoundingHalfSizeVS) {\n    vec3 v = vec3(0.0);\n    vec3 up = cross(right, lookAt);\n    worldPos -= lightPos;\n    v.x = dot(worldPos, right);\n    v.y = dot(worldPos, up);\n    v.z = dot(worldPos, lookAt);\n    vec3 result = step(abs(v), BoundingHalfSizeVS);\n    return result.x * result.y * result.z;\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w) ? -cc_lightDir[i].xyz : cc_lightPos[i].xyz - position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      float illum = 1.0;\n      float att = 1.0;\n      if (IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) {\n        att = GetOutOfRange(position, cc_lightPos[i].xyz, cc_lightDir[i].xyz, cc_lightSizeRangeAngle[i].xyz, cc_lightBoundingSizeVS[i].xyz);\n      } else {\n        float distSqr = dot(SLU, SLU);\n        float litRadius = cc_lightSizeRangeAngle[i].x;\n        float litRadiusSqr = litRadius * litRadius;\n        illum = (IS_POINT_LIGHT(cc_lightPos[i].w) || IS_RANGED_DIRECTIONAL_LIGHT(cc_lightPos[i].w)) ? 1.0 : litRadiusSqr / max(litRadiusSqr , distSqr);\n        float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n        attRadiusSqrInv *= attRadiusSqrInv;\n        att = GetDistAtt(distSqr, attRadiusSqrInv);\n        if (IS_SPOT_LIGHT(cc_lightPos[i].w)) {\n          float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n          float cosOuter = cc_lightSizeRangeAngle[i].z;\n          float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n          float litAngleOffset = -cosOuter * litAngleScale;\n          att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n        }\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    varying highp vec4 v_shadowPos;\n    uniform highp mat4 cc_matLightView;\n  uniform highp mat4 cc_matLightViewProj;\n  uniform highp vec4 cc_shadowProjDepthInfo;\n  uniform highp vec4 cc_shadowProjInfo;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowWHPBInfo;\n    #if CC_SUPPORT_CASCADED_SHADOW_MAP\n      uniform highp vec4 cc_csmViewDir0[4];\n  uniform highp vec4 cc_csmViewDir1[4];\n  uniform highp vec4 cc_csmViewDir2[4];\n  uniform highp vec4 cc_csmAtlas[4];\n  uniform highp mat4 cc_matCSMViewProj[4];\n  uniform highp vec4 cc_csmProjDepthInfo[4];\n  uniform highp vec4 cc_csmProjInfo[4];\n  uniform highp vec4 cc_csmSplitsInfo;\n    #endif\n    #if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n    #define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n    #else\n    #define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n    #endif\n    #if CC_RECEIVE_SHADOW\n      uniform highp sampler2D cc_shadowMap;\n      uniform highp sampler2D cc_spotShadowMap;\n      vec4 shadowTexure(highp sampler2D shadowMap, vec2 coord) {\n          #if defined(CC_USE_WGPU)\n              return texture2DLod(shadowMap, coord, 0.0);\n          #else\n            return texture2D(shadowMap, coord);\n          #endif\n      }\n      float NativePCFShadowFactorHard (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        #if CC_SHADOWMAP_FORMAT == 1\n          return step(shadowNDCPos.z, dot(shadowTexure(shadowMap, shadowNDCPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          return step(shadowNDCPos.z, shadowTexure(shadowMap, shadowNDCPos.xy).x);\n        #endif\n      }\n      float NativePCFShadowFactorSoft (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        vec2 oneTap = 1.0 / shadowMapResolution;\n        vec2 shadowNDCPos_offset = shadowNDCPos.xy + oneTap;\n        float block0, block1, block2, block3;\n        #if CC_SHADOWMAP_FORMAT == 1\n          block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n          block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos.y)).x);\n          block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset.y)).x);\n          block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset.x, shadowNDCPos_offset.y)).x);\n        #endif\n        float coefX   = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block2, block3, coefX);\n        float coefY   = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n        return mix(resultX, resultY, coefY);\n      }\n      float NativePCFShadowFactorSoft3X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        vec2 oneTap = 1.0 / shadowMapResolution;\n        float shadowNDCPos_offset_L = shadowNDCPos.x - oneTap.x;\n        float shadowNDCPos_offset_R = shadowNDCPos.x + oneTap.x;\n        float shadowNDCPos_offset_U = shadowNDCPos.y - oneTap.y;\n        float shadowNDCPos_offset_D = shadowNDCPos.y + oneTap.y;\n        float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n        #if CC_SHADOWMAP_FORMAT == 1\n          block0 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          block0 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_U)).x);\n          block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_U)).x);\n          block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_U)).x);\n          block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos.y)).x);\n          block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos.y)).x);\n          block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos.y)).x);\n          block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_L, shadowNDCPos_offset_D)).x);\n          block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos.x, shadowNDCPos_offset_D)).x);\n          block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, vec2(shadowNDCPos_offset_R, shadowNDCPos_offset_D)).x);\n        #endif\n        float coefX = mod(shadowNDCPos.x, oneTap.x) * shadowMapResolution.x;\n        float coefY = mod(shadowNDCPos.y, oneTap.y) * shadowMapResolution.y;\n        float shadow = 0.0;\n        float resultX = mix(block0, block1, coefX);\n        float resultY = mix(block3, block4, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block1, block2, coefX);\n        resultY = mix(block4, block5, coefX);\n        shadow += mix(resultX , resultY, coefY);\n        resultX = mix(block3, block4, coefX);\n        resultY = mix(block6, block7, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        resultX = mix(block4, block5, coefX);\n        resultY = mix(block7, block8, coefX);\n        shadow += mix(resultX, resultY, coefY);\n        return shadow * 0.25;\n      }\n      float NativePCFShadowFactorSoft5X (vec3 shadowNDCPos, highp sampler2D shadowMap, vec2 shadowMapResolution)\n      {\n        vec2 oneTap = 1.0 / shadowMapResolution;\n        vec2 twoTap = oneTap * 2.0;\n        vec2 offset1 = shadowNDCPos.xy + vec2(-twoTap.x, -twoTap.y);\n        vec2 offset2 = shadowNDCPos.xy + vec2(-oneTap.x, -twoTap.y);\n        vec2 offset3 = shadowNDCPos.xy + vec2(0.0, -twoTap.y);\n        vec2 offset4 = shadowNDCPos.xy + vec2(oneTap.x, -twoTap.y);\n        vec2 offset5 = shadowNDCPos.xy + vec2(twoTap.x, -twoTap.y);\n        vec2 offset6 = shadowNDCPos.xy + vec2(-twoTap.x, -oneTap.y);\n        vec2 offset7 = shadowNDCPos.xy + vec2(-oneTap.x, -oneTap.y);\n        vec2 offset8 = shadowNDCPos.xy + vec2(0.0, -oneTap.y);\n        vec2 offset9 = shadowNDCPos.xy + vec2(oneTap.x, -oneTap.y);\n        vec2 offset10 = shadowNDCPos.xy + vec2(twoTap.x, -oneTap.y);\n        vec2 offset11 = shadowNDCPos.xy + vec2(-twoTap.x, 0.0);\n        vec2 offset12 = shadowNDCPos.xy + vec2(-oneTap.x, 0.0);\n        vec2 offset13 = shadowNDCPos.xy + vec2(0.0, 0.0);\n        vec2 offset14 = shadowNDCPos.xy + vec2(oneTap.x, 0.0);\n        vec2 offset15 = shadowNDCPos.xy + vec2(twoTap.x, 0.0);\n        vec2 offset16 = shadowNDCPos.xy + vec2(-twoTap.x, oneTap.y);\n        vec2 offset17 = shadowNDCPos.xy + vec2(-oneTap.x, oneTap.y);\n        vec2 offset18 = shadowNDCPos.xy + vec2(0.0, oneTap.y);\n        vec2 offset19 = shadowNDCPos.xy + vec2(oneTap.x, oneTap.y);\n        vec2 offset20 = shadowNDCPos.xy + vec2(twoTap.x, oneTap.y);\n        vec2 offset21 = shadowNDCPos.xy + vec2(-twoTap.x, twoTap.y);\n        vec2 offset22 = shadowNDCPos.xy + vec2(-oneTap.x, twoTap.y);\n        vec2 offset23 = shadowNDCPos.xy + vec2(0.0, twoTap.y);\n        vec2 offset24 = shadowNDCPos.xy + vec2(oneTap.x, twoTap.y);\n        vec2 offset25 = shadowNDCPos.xy + vec2(twoTap.x, twoTap.y);\n        float block1, block2, block3, block4, block5, block6, block7, block8, block9, block10, block11, block12, block13, block14, block15, block16, block17, block18, block19, block20, block21, block22, block23, block24, block25;\n        #if CC_SHADOWMAP_FORMAT == 1\n          block1 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset1), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block2 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset2), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block3 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset3), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block4 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset4), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block5 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset5), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block6 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset6), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block7 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset7), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block8 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset8), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block9 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset9), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block10 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset10), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block11 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset11), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block12 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset12), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block13 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset13), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block14 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset14), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block15 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset15), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block16 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset16), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block17 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset17), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block18 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset18), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block19 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset19), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block20 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset20), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block21 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset21), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block22 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset22), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block23 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset23), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block24 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset24), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n          block25 = step(shadowNDCPos.z, dot(shadowTexure(shadowMap, offset25), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0)));\n        #else\n          block1 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset1).x);\n          block2 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset2).x);\n          block3 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset3).x);\n          block4 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset4).x);\n          block5 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset5).x);\n          block6 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset6).x);\n          block7 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset7).x);\n          block8 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset8).x);\n          block9 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset9).x);\n          block10 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset10).x);\n          block11 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset11).x);\n          block12 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset12).x);\n          block13 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset13).x);\n          block14 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset14).x);\n          block15 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset15).x);\n          block16 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset16).x);\n          block17 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset17).x);\n          block18 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset18).x);\n          block19 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset19).x);\n          block20 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset20).x);\n          block21 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset21).x);\n          block22 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset22).x);\n          block23 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset23).x);\n          block24 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset24).x);\n          block25 = step(shadowNDCPos.z, shadowTexure(shadowMap, offset25).x);\n        #endif\n        vec2 coef = fract(shadowNDCPos.xy * shadowMapResolution);\n        vec2 v1X1 = mix(vec2(block1, block6), vec2(block2, block7), coef.xx);\n        vec2 v1X2 = mix(vec2(block2, block7), vec2(block3, block8), coef.xx);\n        vec2 v1X3 = mix(vec2(block3, block8), vec2(block4, block9), coef.xx);\n        vec2 v1X4 = mix(vec2(block4, block9), vec2(block5, block10), coef.xx);\n        float v1 = mix(v1X1.x, v1X1.y, coef.y) + mix(v1X2.x, v1X2.y, coef.y) + mix(v1X3.x, v1X3.y, coef.y) + mix(v1X4.x, v1X4.y, coef.y);\n        vec2 v2X1 = mix(vec2(block6, block11), vec2(block7, block12), coef.xx);\n        vec2 v2X2 = mix(vec2(block7, block12), vec2(block8, block13), coef.xx);\n        vec2 v2X3 = mix(vec2(block8, block13), vec2(block9, block14), coef.xx);\n        vec2 v2X4 = mix(vec2(block9, block14), vec2(block10, block15), coef.xx);\n        float v2 = mix(v2X1.x, v2X1.y, coef.y) + mix(v2X2.x, v2X2.y, coef.y) + mix(v2X3.x, v2X3.y, coef.y) + mix(v2X4.x, v2X4.y, coef.y);\n        vec2 v3X1 = mix(vec2(block11, block16), vec2(block12, block17), coef.xx);\n        vec2 v3X2 = mix(vec2(block12, block17), vec2(block13, block18), coef.xx);\n        vec2 v3X3 = mix(vec2(block13, block18), vec2(block14, block19), coef.xx);\n        vec2 v3X4 = mix(vec2(block14, block19), vec2(block15, block20), coef.xx);\n        float v3 = mix(v3X1.x, v3X1.y, coef.y) + mix(v3X2.x, v3X2.y, coef.y) + mix(v3X3.x, v3X3.y, coef.y) + mix(v3X4.x, v3X4.y, coef.y);\n        vec2 v4X1 = mix(vec2(block16, block21), vec2(block17, block22), coef.xx);\n        vec2 v4X2 = mix(vec2(block17, block22), vec2(block18, block23), coef.xx);\n        vec2 v4X3 = mix(vec2(block18, block23), vec2(block19, block24), coef.xx);\n        vec2 v4X4 = mix(vec2(block19, block24), vec2(block20, block25), coef.xx);\n        float v4 = mix(v4X1.x, v4X1.y, coef.y) + mix(v4X2.x, v4X2.y, coef.y) + mix(v4X3.x, v4X3.y, coef.y) + mix(v4X4.x, v4X4.y, coef.y);\n        float fAvg = (v1 + v2 + v3 + v4) * 0.0625;\n        return fAvg;\n      }\n      bool GetShadowNDCPos(out vec3 shadowNDCPos, vec4 shadowPosWithDepthBias)\n      {\n      \tshadowNDCPos = shadowPosWithDepthBias.xyz / shadowPosWithDepthBias.w * 0.5 + 0.5;\n      \tif (shadowNDCPos.x < 0.0 || shadowNDCPos.x > 1.0 ||\n      \t\tshadowNDCPos.y < 0.0 || shadowNDCPos.y > 1.0 ||\n      \t\tshadowNDCPos.z < 0.0 || shadowNDCPos.z > 1.0) {\n      \t\treturn false;\n      \t}\n      \tshadowNDCPos.xy = cc_cameraPos.w == 1.0 ? vec2(shadowNDCPos.xy.x, 1.0 - shadowNDCPos.xy.y) : shadowNDCPos.xy;\n      \treturn true;\n      }\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, vec3 matViewDir0, vec3 matViewDir1, vec3 matViewDir2, vec2 projScaleXY)\n      {\n        vec4 newShadowPos = shadowPos;\n        if (normalBias > EPSILON_LOWP)\n        {\n          vec3 viewNormal = vec3(dot(matViewDir0, worldNormal), dot(matViewDir1, worldNormal), dot(matViewDir2, worldNormal));\n          if (viewNormal.z < 0.1)\n            newShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n        }\n        return newShadowPos;\n      }\n      vec4 ApplyShadowDepthBias_FaceNormal(vec4 shadowPos, vec3 worldNormal, float normalBias, mat4 matLightView, vec2 projScaleXY)\n      {\n      \tvec4 newShadowPos = shadowPos;\n      \tif (normalBias > EPSILON_LOWP)\n      \t{\n      \t\tvec4 viewNormal = matLightView * vec4(worldNormal, 0.0);\n      \t\tif (viewNormal.z < 0.1)\n      \t\t\tnewShadowPos.xy += viewNormal.xy * projScaleXY * normalBias * clamp(viewNormal.z, 0.001, 0.1);\n      \t}\n      \treturn newShadowPos;\n      }\n      float GetViewSpaceDepthFromNDCDepth_Orthgraphic(float NDCDepth, float projScaleZ, float projBiasZ)\n      {\n      \treturn (NDCDepth - projBiasZ) / projScaleZ;\n      }\n      vec4 ApplyShadowDepthBias_Orthographic(vec4 shadowPos, float viewspaceDepthBias, float projScaleZ, float projBiasZ)\n      {\n      \tfloat coeffA = projScaleZ;\n      \tfloat coeffB = projBiasZ;\n      \tfloat viewSpacePos_z = GetViewSpaceDepthFromNDCDepth_Orthgraphic(shadowPos.z, projScaleZ, projBiasZ);\n      \tviewSpacePos_z += viewspaceDepthBias;\n      \tvec4 result = shadowPos;\n      \tresult.z = viewSpacePos_z * coeffA + coeffB;\n      \treturn result;\n      }\n      float CCGetDirLightShadowFactorHard (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorHard(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCGetDirLightShadowFactorSoft (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorSoft(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCGetDirLightShadowFactorSoft3X (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorSoft3X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCGetDirLightShadowFactorSoft5X (vec4 shadowPosWithDepthBias) {\n    \t  vec3 shadowNDCPos;\n    \t  if (!GetShadowNDCPos(shadowNDCPos, shadowPosWithDepthBias)) {\n    \t\t  return 1.0;\n    \t  }\n        return NativePCFShadowFactorSoft5X(shadowNDCPos, cc_shadowMap, cc_shadowWHPBInfo.xy);\n      }\n      float CCShadowFactorBase(out vec4 shadowPosWithDepthBias, vec4 shadowPos, vec3 N, vec2 shadowBias)\n      {\n        vec4 pos = ApplyShadowDepthBias_FaceNormal(shadowPos, N, shadowBias.y, cc_matLightView, cc_shadowProjInfo.xy);\n        pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, cc_shadowProjDepthInfo.x, cc_shadowProjDepthInfo.y);\n        float realtimeShadow = 1.0;\n        #if CC_DIR_SHADOW_PCF_TYPE == 3\n          realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n        #endif\n        #if CC_DIR_SHADOW_PCF_TYPE == 2\n          realtimeShadow =  CCGetDirLightShadowFactorSoft3X(pos);\n        #endif\n        #if CC_DIR_SHADOW_PCF_TYPE == 1\n          realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n        #endif\n        #if CC_DIR_SHADOW_PCF_TYPE == 0\n          realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n        #endif\n        shadowPosWithDepthBias = pos;\n        return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n      }\n      #if CC_SUPPORT_CASCADED_SHADOW_MAP\n        bool CCGetCSMLevelWithTransition(out highp float ratio, vec3 clipPos) {\n          highp float maxRange = 1.0 - cc_csmSplitsInfo.x;\n          highp float minRange = cc_csmSplitsInfo.x;\n          highp float thresholdInvert = 1.0 / cc_csmSplitsInfo.x;\n          ratio = 0.0;\n          if (clipPos.x <= minRange) {\n            ratio = clipPos.x * thresholdInvert;\n            return true;\n          }\n          if (clipPos.x >= maxRange) {\n            ratio = 1.0 - (clipPos.x - maxRange) * thresholdInvert;\n            return true;\n          }\n          if (clipPos.y <= minRange) {\n            ratio = clipPos.y  * thresholdInvert;\n            return true;\n          }\n          if (clipPos.y >= maxRange) {\n            ratio = 1.0 - (clipPos.y - maxRange) * thresholdInvert;\n            return true;\n          }\n          return false;\n        }\n        bool CCHasCSMLevel(int level, vec3 worldPos) {\n          highp float layerThreshold = cc_csmViewDir0[0].w;\n          bool hasLevel = false;\n          for (int i = 0; i < 4; i++) {\n            if (i == level) {\n              vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n              vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n              if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n                  clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n                  clipPos.z >= 0.0 && clipPos.z <= 1.0) {\n                hasLevel = true;\n              }\n            }\n          }\n          return hasLevel;\n        }\n        void CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos, int level) {\n          highp float layerThreshold = cc_csmViewDir0[0].w;\n          for (int i = 0; i < 4; i++) {\n            vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n            vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n            if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n                clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n                clipPos.z >= 0.0 && clipPos.z <= 1.0 && i == level) {\n              csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n              csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n              shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n              shadowProjInfo = cc_csmProjInfo[i];\n              shadowViewDir0 = cc_csmViewDir0[i].xyz;\n              shadowViewDir1 = cc_csmViewDir1[i].xyz;\n              shadowViewDir2 = cc_csmViewDir2[i].xyz;\n            }\n          }\n        }\n        int CCGetCSMLevel(out bool isTransitionArea, out highp float transitionRatio, out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n        {\n          int level = -1;\n          highp float layerThreshold = cc_csmViewDir0[0].w;\n          for (int i = 0; i < 4; i++) {\n            vec4 shadowPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n            vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n            if (clipPos.x >= layerThreshold && clipPos.x <= (1.0 - layerThreshold) &&\n                clipPos.y >= layerThreshold && clipPos.y <= (1.0 - layerThreshold) &&\n                clipPos.z >= 0.0 && clipPos.z <= 1.0 && level < 0) {\n              #if CC_CASCADED_LAYERS_TRANSITION\n                isTransitionArea = CCGetCSMLevelWithTransition(transitionRatio, clipPos);\n              #endif\n              csmPos = cc_matCSMViewProj[i] * vec4(worldPos.xyz, 1.0);\n              csmPos.xy = csmPos.xy * cc_csmAtlas[i].xy + cc_csmAtlas[i].zw;\n              shadowProjDepthInfo = cc_csmProjDepthInfo[i];\n              shadowProjInfo = cc_csmProjInfo[i];\n              shadowViewDir0 = cc_csmViewDir0[i].xyz;\n              shadowViewDir1 = cc_csmViewDir1[i].xyz;\n              shadowViewDir2 = cc_csmViewDir2[i].xyz;\n              level = i;\n            }\n          }\n          return level;\n        }\n        int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos)\n        {\n          bool isTransitionArea = false;\n          highp float transitionRatio = 0.0;\n          return CCGetCSMLevel(isTransitionArea, transitionRatio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n        }\n        float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias)\n        {\n          bool isTransitionArea = false;\n          highp float ratio = 0.0;\n          csmPos = vec4(1.0);\n          vec4 shadowProjDepthInfo, shadowProjInfo;\n          vec3 shadowViewDir0, shadowViewDir1, shadowViewDir2;\n          int level = -1;\n          #if CC_CASCADED_LAYERS_TRANSITION\n            level = CCGetCSMLevel(isTransitionArea, ratio, csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n          #else\n            level = CCGetCSMLevel(csmPos, shadowProjDepthInfo, shadowProjInfo, shadowViewDir0, shadowViewDir1, shadowViewDir2, worldPos);\n          #endif\n          if (level < 0) { return 1.0; }\n          vec4 pos = ApplyShadowDepthBias_FaceNormal(csmPos, N, shadowBias.y, shadowViewDir0, shadowViewDir1, shadowViewDir2, shadowProjInfo.xy);\n          pos = ApplyShadowDepthBias_Orthographic(pos, shadowBias.x, shadowProjDepthInfo.x, shadowProjDepthInfo.y);\n          csmPosWithBias = pos;\n          float realtimeShadow = 1.0;\n          #if CC_DIR_SHADOW_PCF_TYPE == 3\n            realtimeShadow = CCGetDirLightShadowFactorSoft5X(pos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 2\n            realtimeShadow = CCGetDirLightShadowFactorSoft3X(pos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 1\n            realtimeShadow = CCGetDirLightShadowFactorSoft(pos);\n          #endif\n          #if CC_DIR_SHADOW_PCF_TYPE == 0\n            realtimeShadow = CCGetDirLightShadowFactorHard(pos);\n          #endif\n          #if CC_CASCADED_LAYERS_TRANSITION\n            vec4 nextCSMPos = vec4(1.0);\n            vec4 nextShadowProjDepthInfo, nextShadowProjInfo;\n            vec3 nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2;\n            float nextRealtimeShadow = 1.0;\n            CCGetCSMLevel(nextCSMPos, nextShadowProjDepthInfo, nextShadowProjInfo, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, worldPos, level + 1);\n            bool hasNextLevel = CCHasCSMLevel(level + 1, worldPos);\n            if (hasNextLevel && isTransitionArea) {\n              vec4 nexPos = ApplyShadowDepthBias_FaceNormal(nextCSMPos, N, shadowBias.y, nextShadowViewDir0, nextShadowViewDir1, nextShadowViewDir2, nextShadowProjInfo.xy);\n              nexPos = ApplyShadowDepthBias_Orthographic(nexPos, shadowBias.x, nextShadowProjDepthInfo.x, nextShadowProjDepthInfo.y);\n              #if CC_DIR_SHADOW_PCF_TYPE == 3\n                nextRealtimeShadow = CCGetDirLightShadowFactorSoft5X(nexPos);\n              #endif\n              #if CC_DIR_SHADOW_PCF_TYPE == 2\n                nextRealtimeShadow = CCGetDirLightShadowFactorSoft3X(nexPos);\n              #endif\n              #if CC_DIR_SHADOW_PCF_TYPE == 1\n                nextRealtimeShadow = CCGetDirLightShadowFactorSoft(nexPos);\n              #endif\n              #if CC_DIR_SHADOW_PCF_TYPE == 0\n                nextRealtimeShadow = CCGetDirLightShadowFactorHard(nexPos);\n              #endif\n              return mix(mix(nextRealtimeShadow, realtimeShadow, ratio), 1.0, cc_shadowNFLSInfo.w);\n            }\n            return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n          #else\n            return mix(realtimeShadow, 1.0, cc_shadowNFLSInfo.w);\n          #endif\n        }\n      #else\n        int CCGetCSMLevel(out vec4 csmPos, out vec4 shadowProjDepthInfo, out vec4 shadowProjInfo, out vec3 shadowViewDir0, out vec3 shadowViewDir1, out vec3 shadowViewDir2, vec3 worldPos) {\n          return -1;\n        }\n        float CCCSMFactorBase(out vec4 csmPos, out vec4 csmPosWithBias, vec3 worldPos, vec3 N, vec2 shadowBias) {\n          csmPos = cc_matLightViewProj * vec4(worldPos, 1.0);\n          return CCShadowFactorBase(csmPosWithBias, csmPos, N, shadowBias);\n        }\n      #endif\n      float CCShadowFactorBase(vec4 shadowPos, vec3 N, vec2 shadowBias) {\n        vec4 shadowPosWithDepthBias;\n        return CCShadowFactorBase(shadowPosWithDepthBias, shadowPos, N, shadowBias);\n      }\n      float CCCSMFactorBase(vec3 worldPos, vec3 N, vec2 shadowBias) {\n        vec4 csmPos, csmPosWithBias;\n        return CCCSMFactorBase(csmPos, csmPosWithBias, worldPos, N, shadowBias);\n      }\n    #endif\n        #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 position;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    position = unpackHighpData(s.position, s.position_fract_part);\n    #else\n    position = s.position;\n    #endif\n    vec3 V = normalize(cc_cameraPos.xyz - position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight + EPSILON_LOWP, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 dirlightContrib = diffuse + specular;\n    float shadow = 1.0;\n    #if CC_RECEIVE_SHADOW && CC_SHADOW_TYPE == 2\n    if(s.shadowCover < NL && cc_mainLitDir.w > 0.0) {\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 2\n        shadow = CCCSMFactorBase(position, N, s.shadowBias);\n      #endif\n      #if CC_DIR_LIGHT_SHADOW_TYPE == 1\n        shadow = CCShadowFactorBase(v_shadowPos, N, s.shadowBias);\n      #endif\n    }\n    #endif\n    dirlightContrib *= shadow;\n    vec3 finalColor = lightColor * dirlightContrib;\n    finalColor += s.emissive;\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\n    uniform vec4 baseColor;\n    uniform vec4 colorScaleAndCutoff;\n    uniform vec4 shadeColor1;\n    uniform vec4 shadeColor2;\n    uniform vec4 specular;\n    uniform vec4 shadeParams;\n    uniform vec4 miscParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleAndStrenth;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return gamma;\n    }\n  #endif\n#endif\n  return gamma * gamma;\n}\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\n#if CC_RECEIVE_SHADOW\n  varying mediump vec2 v_shadowBias;\n#endif\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\nvarying mediump vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying mediump vec4 v_tangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_1ST_SHADE_MAP\n  uniform sampler2D shadeMap1;\n#endif\n#if USE_2ND_SHADE_MAP\n  uniform sampler2D shadeMap2;\n#endif\n#if USE_SPECULAR_MAP\n  uniform sampler2D specularMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out ToonSurface s) {\n  s.shade2 = shadeColor2.rgb * colorScaleAndCutoff.rgb;\n  #if USE_2ND_SHADE_MAP\n    s.shade2 *= SRGBToLinear(texture2D(shadeMap2, v_uv).rgb);\n  #endif\n  s.shade1 = shadeColor1.rgb * colorScaleAndCutoff.rgb;\n  #if USE_1ST_SHADE_MAP\n    s.shade1 *= SRGBToLinear(texture2D(shadeMap1, v_uv).rgb);\n    #if SHADE_MAP_1_AS_SHADE_MAP_2\n      s.shade2 *= s.shade1.rgb;\n    #endif\n  #endif\n  vec4 localBaseColor = baseColor;\n  #if USE_BASE_COLOR_MAP\n    vec4 baseColorMap = texture2D(baseColorMap, v_uv);\n    baseColorMap.rgb = SRGBToLinear(baseColorMap.rgb);\n    localBaseColor *= baseColorMap;\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_1\n      s.shade1 *= baseColorMap.rgb;\n    #endif\n    #if BASE_COLOR_MAP_AS_SHADE_MAP_2\n      s.shade2 *= baseColorMap.rgb;\n    #endif\n  #endif\n  s.baseColor = localBaseColor;\n  s.baseColor.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if CC_RECEIVE_SHADOW\n    s.shadowBias = v_shadowBias;\n  #endif\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    vec3 bitangent = cross(v_normal, v_tangent.xyz) * (v_tangent.w > 0.0 ? 1.0 : -1.0);\n    s.normal =\n      (nmmp.x * emissiveScaleAndStrenth.w) * normalize(v_tangent.xyz) +\n      (nmmp.y * emissiveScaleAndStrenth.w) * normalize(bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n  packHighpData(s.position, s.position_fract_part, v_position);\n  #else\n  s.position = v_position;\n  #endif\n  s.specular = specular;\n  #if USE_SPECULAR_MAP\n    s.specular.rgb *= SRGBToLinear(texture2D(specularMap, v_uv).rgb);\n  #endif\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n  s.shadowCover = miscParams.x;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":141,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":109}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]},{"name":"CC_DIR_SHADOW_PCF_TYPE","type":"number","range":[0,3]},{"name":"CC_CASCADED_LAYERS_TRANSITION","type":"boolean"},{"name":"CC_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_DIR_LIGHT_SHADOW_TYPE","type":"number","range":[0,3]},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SURFACES_ENABLE_DEBUG_VIEW","type":"boolean"},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"USE_BASE_COLOR_MAP","type":"boolean"},{"name":"USE_1ST_SHADE_MAP","type":"boolean"},{"name":"USE_2ND_SHADE_MAP","type":"boolean"},{"name":"USE_SPECULAR_MAP","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"SHADE_MAP_1_AS_SHADE_MAP_2","type":"boolean"},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_1","type":"boolean"},{"name":"BASE_COLOR_MAP_AS_SHADE_MAP_2","type":"boolean"}]},{"hash":1215055059,"name":"legacy/toon|shadow-caster-vs:vert|shadow-caster-fs:frag","blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1},{"name":"baseColor","type":16,"count":1},{"name":"colorScaleAndCutoff","type":16,"count":1},{"name":"shadeColor1","type":16,"count":1},{"name":"shadeColor2","type":16,"count":1},{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"miscParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"baseColorMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":1,"defines":["USE_BASE_COLOR_MAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","stageFlags":16,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nout vec2 v_uv;\nout vec4 v_worldPos;\nout highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.zw;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 baseColor;\n  vec4 colorScaleAndCutoff;\n  vec4 shadeColor1;\n  vec4 shadeColor2;\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 miscParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  layout(std140) uniform CCCSM {\n    highp vec4 cc_csmViewDir0[4];\n    highp vec4 cc_csmViewDir1[4];\n    highp vec4 cc_csmViewDir2[4];\n    highp vec4 cc_csmAtlas[4];\n    highp mat4 cc_matCSMViewProj[4];\n    highp vec4 cc_csmProjDepthInfo[4];\n    highp vec4 cc_csmProjInfo[4];\n    highp vec4 cc_csmSplitsInfo;\n  };\n#endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  layout(std140) uniform CCGlobal {\n    highp   vec4 cc_time;\n    mediump vec4 cc_screenSize;\n    mediump vec4 cc_nativeSize;\n    mediump vec4 cc_probeInfo;\n    mediump vec4 cc_debug_view_mode;\n  };\n  layout(std140) uniform CCCamera {\n    highp   mat4 cc_matView;\n    highp   mat4 cc_matViewInv;\n    highp   mat4 cc_matProj;\n    highp   mat4 cc_matProjInv;\n    highp   mat4 cc_matViewProj;\n    highp   mat4 cc_matViewProjInv;\n    highp   vec4 cc_cameraPos;\n    mediump vec4 cc_surfaceTransform;\n    mediump vec4 cc_screenScale;\n    mediump vec4 cc_exposure;\n    mediump vec4 cc_mainLitDir;\n    mediump vec4 cc_mainLitColor;\n    mediump vec4 cc_ambientSky;\n    mediump vec4 cc_ambientGround;\n    mediump vec4 cc_fogColor;\n    mediump vec4 cc_fogBase;\n    mediump vec4 cc_fogAdd;\n    mediump vec4 cc_nearFar;\n    mediump vec4 cc_viewPort;\n  };\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nin vec2 v_uv;\nin vec4 v_worldPos;\nin highp vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_ALPHA_TEST\n    #if USE_BASE_COLOR_MAP\n      baseColor *= texture(baseColorMap, v_uv);\n    #endif\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n    uniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\nvarying vec2 v_uv;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * v_worldPos;\n  v_clip_depth = clipPos.zw;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n   uniform vec4 baseColor;\n   uniform vec4 colorScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\n  ret = fract(ret);\n  ret -= vec4(ret.yzw, 0.0) / 255.0;\n  return ret;\n}\n#define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\nuniform highp mat4 cc_matLightView;\n  uniform mediump vec4 cc_shadowNFLSInfo;\n  uniform mediump vec4 cc_shadowLPNNInfo;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\nfloat GetLinearDepthFromViewSpace(vec3 viewPos, float near, float far) {\n  float dist = length(viewPos);\n  return (dist - near) / (far - near);\n}\nfloat CCGetLinearDepth(vec3 worldPos, float viewSpaceBias) {\n\tvec4 viewPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\n  viewPos.z += viewSpaceBias;\n\treturn GetLinearDepthFromViewSpace(viewPos.xyz, cc_shadowNFLSInfo.x, cc_shadowNFLSInfo.y);\n}\nfloat CCGetLinearDepth(vec3 worldPos) {\n\treturn CCGetLinearDepth(worldPos, 0.0);\n}\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvarying vec2 v_uv;\nvarying vec4 v_worldPos;\nvarying highp vec2 v_clip_depth;\n#if USE_BASE_COLOR_MAP\n  uniform sampler2D baseColorMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = baseColor;\n  #if USE_ALPHA_TEST\n    #if USE_BASE_COLOR_MAP\n      baseColor *= texture2D(baseColorMap, v_uv);\n    #endif\n    if (baseColor.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  highp float clipDepth = v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5;\n  #if CC_SHADOWMAP_USE_LINEAR_DEPTH\n    if (IS_SPOT_LIGHT(cc_shadowLPNNInfo.x)) {\n      clipDepth = CCGetLinearDepth(v_worldPos.xyz);\n    }\n  #endif\n  #if CC_SHADOWMAP_FORMAT == 1\n    return packDepthToRGBA(clipDepth);\n  #else\n    return vec4(clipDepth, 1.0, 1.0, 1.0);\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]},{"name":"CCGlobal","defines":["CC_RECEIVE_SHADOW"]},{"name":"CCCamera","defines":["CC_RECEIVE_SHADOW"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":58,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":109}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"USE_BASE_COLOR_MAP","type":"boolean"},{"name":"USE_ALPHA_TEST","type":"boolean"},{"name":"ALPHA_TEST_CHANNEL","type":"string","options":["a","r","g","b"]},{"name":"CC_SHADOWMAP_USE_LINEAR_DEPTH","type":"boolean"},{"name":"CC_SHADOWMAP_FORMAT","type":"number","range":[0,3]}]},{"hash":3680218420,"name":"legacy/toon|planar-shadow-vs:vert|planar-shadow-fs:frag","blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nvec4 CalculatePlanarShadowPos(vec3 meshWorldPos, vec3 cameraPos, vec3 lightDir, vec4 plane) {\n  vec3 P = meshWorldPos;\n  vec3 L = lightDir;\n  vec3 N = plane.xyz;\n  float d = plane.w + EPSILON_LOWP;\n  float dist = (-d - dot(P, N)) / (dot(L, N) + EPSILON_LOWP);\n  vec3 shadowPos = P + L * dist;\n  return vec4(shadowPos, dist);\n}\nvec4 CalculatePlanarShadowClipPos(vec4 shadowPos, vec3 cameraPos, mat4 matView, mat4 matProj, vec4 nearFar, float bias) {\n  vec4 camPos = matView * vec4(shadowPos.xyz, 1.0);\n  float lerpCoef = saturate((nearFar.z < 0.0 ? -camPos.z : camPos.z) / (nearFar.y - nearFar.x));\n  camPos.z += mix(nearFar.x * 0.01, nearFar.y * EPSILON_LOWP * bias, lerpCoef);\n  return matProj * camPos;\n}\nout float v_dist;\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec3 worldPos = (matWorld * position).xyz;\n  vec4 shadowPos = CalculatePlanarShadowPos(worldPos, cc_cameraPos.xyz, cc_mainLitDir.xyz, cc_planarNDInfo);\n  position = CalculatePlanarShadowClipPos(shadowPos, cc_cameraPos.xyz, cc_matView, cc_matProj, cc_nearFar, cc_shadowWHPBInfo.w);\n  v_dist = shadowPos.w;\n  return position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  highp vec4 cc_shadowInvProjDepthInfo;\n  highp vec4 cc_shadowProjDepthInfo;\n  highp vec4 cc_shadowProjInfo;\n  mediump vec4 cc_shadowNFLSInfo;\n  mediump vec4 cc_shadowWHPBInfo;\n  mediump vec4 cc_shadowLPNNInfo;\n  lowp vec4 cc_shadowColor;\n  mediump vec4 cc_planarNDInfo;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nin float v_dist;\nvec4 frag () {\n  if(v_dist < 0.0)\n    discard;\n  return CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_nearFar;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nuniform mediump vec4 cc_shadowWHPBInfo;\n  uniform mediump vec4 cc_planarNDInfo;\nvec4 CalculatePlanarShadowPos(vec3 meshWorldPos, vec3 cameraPos, vec3 lightDir, vec4 plane) {\n  vec3 P = meshWorldPos;\n  vec3 L = lightDir;\n  vec3 N = plane.xyz;\n  float d = plane.w + EPSILON_LOWP;\n  float dist = (-d - dot(P, N)) / (dot(L, N) + EPSILON_LOWP);\n  vec3 shadowPos = P + L * dist;\n  return vec4(shadowPos, dist);\n}\nvec4 CalculatePlanarShadowClipPos(vec4 shadowPos, vec3 cameraPos, mat4 matView, mat4 matProj, vec4 nearFar, float bias) {\n  vec4 camPos = matView * vec4(shadowPos.xyz, 1.0);\n  float lerpCoef = saturate((nearFar.z < 0.0 ? -camPos.z : camPos.z) / (nearFar.y - nearFar.x));\n  camPos.z += mix(nearFar.x * 0.01, nearFar.y * EPSILON_LOWP * bias, lerpCoef);\n  return matProj * camPos;\n}\nvarying float v_dist;\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec3 worldPos = (matWorld * position).xyz;\n  vec4 shadowPos = CalculatePlanarShadowPos(worldPos, cc_cameraPos.xyz, cc_mainLitDir.xyz, cc_planarNDInfo);\n  position = CalculatePlanarShadowClipPos(shadowPos, cc_cameraPos.xyz, cc_matView, cc_matProj, cc_nearFar, cc_shadowWHPBInfo.w);\n  v_dist = shadowPos.w;\n  return position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform lowp vec4 cc_shadowColor;\nvec4 CCFragOutput (vec4 color) {\n  return color;\n}\nvarying float v_dist;\nvec4 frag () {\n  if(v_dist < 0.0)\n    discard;\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":90,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":58}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"}]}],[{"passes":[{"program":"legacy/toon|legacy/main-functions/outline-vs:vert|legacy/main-functions/outline-fs:frag","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true},"properties":{"lineWidth":{"type":13,"value":[10],"handleInfo":["outlineParams",0,13]},"depthBias":{"type":13,"value":[0],"handleInfo":["outlineParams",1,13]},"baseColor":{"type":16},"baseColorMap":{"value":"grey","type":28},"outlineParams":{"type":16,"value":[10,0,0,0]}}},{"program":"legacy/toon|toon-vs:vert|toon-fs:frag","properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[0.6,0.6,0.6,1],"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"linear":true,"type":16,"value":[0.4,0.4,0.4,1]},"shadeColor2":{"linear":true,"type":16,"value":[0.2,0.2,0.2,1]},"specular":{"linear":true,"type":16,"value":[1,1,1,0.3]},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"shadowCover":{"type":13,"value":[0.5],"handleInfo":["miscParams",0,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrength":{"slide":true,"step":0.001,"type":13,"value":[1],"range":[0,5],"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"shadeParams":{"type":16,"value":[0.8,0.001,0.5,0.001]},"miscParams":{"type":16,"value":[0.5,0,0,0]},"emissiveScaleAndStrenth":{"type":16,"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white"}}},{"phase":"forward-add","propertyIndex":1,"program":"legacy/toon|toon-vs:vert|toon-fs:frag","embeddedMacros":{"CC_FORWARD_ADD":true},"blendState":{"targets":[{"blend":true,"blendSrc":1,"blendDst":1,"blendSrcAlpha":0,"blendDstAlpha":1}]},"depthStencilState":{"depthFunc":2,"depthTest":true,"depthWrite":false},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"linear":true,"type":16,"value":[0.6,0.6,0.6,1],"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"linear":true,"type":16,"value":[0.4,0.4,0.4,1]},"shadeColor2":{"linear":true,"type":16,"value":[0.2,0.2,0.2,1]},"specular":{"linear":true,"type":16,"value":[1,1,1,0.3]},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"shadowCover":{"type":13,"value":[0.5],"handleInfo":["miscParams",0,13]},"emissive":{"linear":true,"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrength":{"slide":true,"step":0.001,"type":13,"value":[1],"range":[0,5],"handleInfo":["emissiveScaleAndStrenth",3,13]},"normalMap":{"value":"normal","type":28},"mainTexture":{"value":"white","type":28,"handleInfo":["baseColorMap",0,28]},"shadeMap1":{"value":"white","type":28},"shadeMap2":{"value":"white","type":28},"specularMap":{"value":"white","type":28},"emissiveMap":{"value":"grey","type":28},"baseColor":{"type":16,"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"shadeParams":{"type":16,"value":[0.8,0.001,0.5,0.001]},"miscParams":{"type":16,"value":[0.5,0,0,0]},"emissiveScaleAndStrenth":{"type":16,"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white"}}},{"phase":"shadow-caster","propertyIndex":1,"program":"legacy/toon|shadow-caster-vs:vert|shadow-caster-fs:frag","rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[0.6,0.6,0.6,1],"handleInfo":["baseColor",0,16]},"colorScale":{"type":15,"value":[1,1,1],"handleInfo":["colorScaleAndCutoff",0,15]},"alphaThreshold":{"type":13,"value":[0.5],"handleInfo":["colorScaleAndCutoff",3,13]},"shadeColor1":{"type":16,"value":[0.4,0.4,0.4,1]},"shadeColor2":{"type":16,"value":[0.2,0.2,0.2,1]},"specular":{"type":16,"value":[1,1,1,0.3]},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1]},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"handleInfo":["emissiveScaleAndStrenth",3,13]},"mainTexture":{"value":"white","type":28,"handleInfo":["baseColorMap",0,28]},"baseColor":{"type":16,"value":[0.6,0.6,0.6,1]},"colorScaleAndCutoff":{"type":16,"value":[1,1,1,0.5]},"shadeParams":{"type":16,"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"value":[1,1,1,1]},"baseColorMap":{"type":28,"value":"white"}}},{"phase":"planar-shadow","propertyIndex":0,"program":"legacy/toon|planar-shadow-vs:vert|planar-shadow-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false,"stencilTestFront":true,"stencilFuncFront":5,"stencilPassOpFront":2,"stencilRefBack":128,"stencilRefFront":128,"stencilReadMaskBack":128,"stencilReadMaskFront":128,"stencilWriteMaskBack":128,"stencilWriteMaskFront":128}},{"phase":"deferred-forward","propertyIndex":0,"program":"legacy/toon|legacy/main-functions/outline-vs:vert|legacy/main-functions/outline-fs:frag","switch":"USE_OUTLINE_PASS","rasterizerState":{"cullMode":1},"depthStencilState":{"depthFunc":3,"depthTest":true,"depthWrite":true}},{"phase":"deferred-forward","propertyIndex":1,"program":"legacy/toon|toon-vs:vert|toon-fs:frag"}]}]]],0,0,[],[],[]],[[[15,"Skin-0",753820634,["RootNode/Bone004/Bone005/Bone006","RootNode/Bone004/Bone005","RootNode/Bone004","RootNode/Bone001/Bone002/Bone003","RootNode/Bone001/Bone002","RootNode/Bone001"],[[[7,0.0004333891556598246,0.10229005664587021,0.21936364471912384,0,-0.0009294628980569541,-0.21936167776584625,0.10229097306728363,0,0.24203883111476898,-0.0010255376109853387,2.406476085070608e-8,0,-0.08006425946950912,0.028319520875811577,-0.005389618221670389,1],[7,0.0006473671528510749,0.10228893905878067,0.21936364471912384,0,-0.001388339907862246,-0.21935929358005524,0.10229097306728363,0,0.24203617870807648,-0.0015318524092435837,2.4064471304541257e-8,0,-0.04029082506895065,0.0284869447350502,-0.005389610305428505,1],[7,-0.0006353461649268866,0.10228794068098068,0.21936413645744324,0,0.0013624817365780473,-0.21935993432998657,0.10228990018367767,0,0.2420363426208496,0.0015033365925773978,1.664581716909197e-8,0,-0.0001784319174475968,0.02797948755323887,-0.0053894720040261745,1],[7,0.0004333891556598246,0.10229005664587021,0.21936364471912384,0,-0.0009294628980569541,-0.21936167776584625,0.10229097306728363,0,0.24203883111476898,-0.0010255376109853387,2.406476085070608e-8,0,-0.08025984466075897,-0.017842883244156837,0.01121316384524107,1],[7,0.0006473671528510749,0.10228893905878067,0.21936364471912384,0,-0.001388339907862246,-0.21935929358005524,0.10229097306728363,0,0.24203617870807648,-0.0015318524092435837,2.4064471304541257e-8,0,-0.040582988411188126,-0.017674952745437622,0.011213171295821667,1],[7,-0.0006353461649268866,0.10228794068098068,0.21936413645744324,0,0.0013624817365780473,-0.21935993432998657,0.10228990018367767,0,0.2420363426208496,0.0015033365925773978,1.664581716909197e-8,0,0.00010828844096977264,-0.01818251982331276,0.011213085614144802,1]],8,8,8,8,8,8]]],0,0,[],[],[]],[[[16,".bin",694763540,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":8080,"length":462,"count":231,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":8080,"count":101,"stride":80},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5]]},"minPosition",8,[1,-0.23816974461078644,-0.3651643395423889,-0.02080436609685421],"maxPosition",8,[1,0.2359408587217331,0.26479941606521606,0.6728445887565613]]],-1],0,0,[],[],[]],[[{"fmt":"0","w":0,"h":0},-1],[1],0,[],[],[]],[[{"base":"2,2,0,0,2,0","mipmaps":["aeGN7qxuBKPb9w7lUz+bqH"]}],[2],0,[],[],[]],[[[19,"grass",[{"blendState":{"targets":[{}]},"depthStencilState":{},"rasterizerState":{}}],[{"USE_TEXTURE":true}],[[[{"alphaThreshold":0},"mainTexture",6,0]],11]]],0,0,[0,0],[6,7],[13,14]],[[[21,"soldier"],[30,"soldier",[-3],[[18,true,-2,[4,"04W3Kzvb9BZbZUGFZzfzi5"],[12],13]],[0,"6dMvPN2t1B66O9Zc3HG8dr",null,null,null,-1,0],[1,0,0.956,1.402]],[10,"RootNode",1,[-4,-5,-6,-7,-8],[0,"a5uiqiY3JH2IVaNOBBe7fQ",null,null,null,1,0]],[31,"Bip001 Spine",[-9,-10,-11],[0,"deedfocu1E0amfQjzHnnD8",null,null,null,1,0],[1,0.0765029862523079,-0.000119566058856435,1.06260117149759e-7],[3,-0.000002080475910607327,-6.936759723456761e-7,0.0003981589901667568,0.9999999207323014],[1,-0.00023837338537102568,-0.00007939450691674313,0.045625660794268635]],[32,"Bip001 Neck",[-12,-13,-14],[0,"de+U9IqPVD+qUUY0y7H/86",null,null,null,1,0],[1,0.15020164847374,-0.0000435724105045665,-1.20852522433879e-10]],[37,"Bip001",2,[[[5,"Bip001 Footsteps",-15,[0,"24sP2WouNOyq9Pp+iqRgiX",null,null,null,1,0],[1,-5.16987871290063e-28,0,-0.734457075595856],[3,-6.921034890422563e-34,6.921044533149828e-34,0.7071063043492202,0.7071072580235535],[1,0,-1.1216009582263186e-31,90]],-16],4,1],[0,"15XJ/3651AFKLyr6XRj3d7",null,null,null,1,0],[1,0,0.738336980342865,-3.74271143591121e-12],[3,-0.5000003576277411,-0.4999996423720031,-0.4999996423720031,0.5000003576277411],[1,-90,-89.99991803772988,0]],[8,"soldier",2,[[39,1,-17,[4,"78XZsd31xPjIsSP2888FcN"],[0],[2],1,1,2]],[0,"824q3ldSpHoYl9xi6zWeg4",null,null,null,1,0],[3,0.9999999999999953,0,0,-9.735359185469814e-8],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998884410013,0,0]],[33,"Bip001 Pelvis",5,[3],[0,"9brOPlFAxPnLhkrpP6KbLQ",null,null,null,1,0],[3,-0.4999999925491744,-0.4999999925491744,-0.4999993070957696,0.5000007078049007],[1,-89.9999197452773,-89.9999197452773,-0.0000017074910412130916]],[12,"Bip001 L Thigh",3,[-18],[0,"4aENadJ59Io4SS6BMn9Aw4",null,null,null,1,0],[1,-0.0765029117465019,0.000180334449396469,0.0665242150425911],[3,-0.015412850192755845,0.9969698713847834,0.002043751751963479,-0.07621904406852757],[1,-0.098918034361683,-171.25793904676914,-1.7789668366715101]],[12,"Bip001 L Calf",8,[-19],[0,"71+6ovA8dDUowhlyNGBIbM",null,null,null,1,0],[1,0.368020862340927,-2.38418573772492e-9,1.90734859017994e-8],[3,-3.77253945323161e-21,-4.658679694134547e-18,-0.0008097870399876981,0.999999672122421],[1,-8.646032309262241e-19,-5.338462443351186e-16,-0.09279476953314847]],[12,"Bip001 L Foot",9,[-20],[0,"71/rP0sWxM1bfHuNwls2lv",null,null,null,1,0],[1,0.29802131652832,-2.38418573772492e-9,0],[3,0.0020737143220202685,-0.07621822672483194,0.016616994877612996,0.9969505289155877],[1,0.3822464844159605,-8.749946017824339,1.8805865416881686]],[3,"Bip001 L Toe0",10,[[34,"Bip001 L Toe0Nub",-21,[0,"b7ARhVJWFJP4yiboWbM1Xs",null,null,null,1,0],[1,0.00997863244265318,-2.98023217215615e-10,3.55271359939116e-17],[3,9.55341250274695e-16,-2.4399608215727e-23,1,1.83758927467374e-15],[1,-1,-1,-1],[1,180,-179.9999999999999,2.1057221983462293e-13]]],[0,"b7IX4wc+BII5SOxaDKm4bu",null,null,null,1,0],[1,0.0765028968453407,0.0984558463096619,1.90734859017994e-8],[3,-1.5454308319985125e-8,-1.5454308319985125e-8,0.7071067811865472,0.7071067811865472],[1,0,-0.0000025044778683729224,90]],[12,"Bip001 R Thigh",3,[-22],[0,"baRkxlpMJMup2UzoK3llZt",null,null,null,1,0],[1,-0.0765029117465019,0.000180703471414745,-0.0665242150425911],[3,-0.0154126518850906,0.9969698755273314,-0.0020409899233692465,0.07621910398987286],[1,0.09860398393799301,171.25792731952373,-1.7789200579558455]],[12,"Bip001 R Calf",12,[-23],[0,"8a4oYAyD9MkZi9aL5G15gW",null,null,null,1,0],[1,0.36802089214325,0,-3.55271359939116e-17],[3,2.226103102352033e-19,7.125063520427799e-18,-0.0008097898921612967,0.9999996721201113],[1,2.6170459347986135e-17,8.164935972515574e-16,-0.09279509636827488]],[12,"Bip001 R Foot",13,[-24],[0,"cdWn1utjJOUaNdTLXxb/CR",null,null,null,1,0],[1,0.29802131652832,0,-3.81469718035987e-8],[3,-0.002073778117879438,0.07621821928385913,0.016617013506159614,0.9969505290412618],[1,-0.38225392566993516,8.749945293799216,1.8805881155171484]],[3,"Bip001 R Toe0",14,[[23,"Bip001 R Toe0Nub",-25,[0,"77BI3YwgNJqKMpf0rJhZ9s",null,null,null,1,0],[1,0.00997863244265318,-2.98023217215615e-10,7.10542719878232e-17]]],[0,"26R5ll6SNGP5ArlFhrFOzH",null,null,null,1,0],[1,0.0765028968453407,0.0984558537602425,1.90734859017994e-8],[3,-1.5454308319985125e-8,-1.5454308319985125e-8,0.7071067811865472,0.7071067811865472],[1,0,-0.0000025044778683729224,90]],[35,"Bip001 Spine1",3,[4],[0,"78+5xpqyNL2aHMIBr4YHvg",null,null,null,1,0],[1,0.150201484560966,-0.000119601711048745,-3.31727090241429e-10]],[12,"Bip001 L Clavicle",4,[-26],[0,"c67UVUfoFCNLAcx8dX7SW1",null,null,null,1,0],[1,0,0.0000435078145528678,0.0232834853231907],[3,0.6087613827170933,-0.0002434881366867595,0.7933532758994495,0.0003150325566206266],[1,179.9558877717535,-104.99999523006848,0.01165464185401893]],[12,"Bip001 L UpperArm",17,[-27],[0,"66qUHYCHZNMoAvIMM8jTZn",null,null,null,1,0],[1,0.272405058145523,4.54747340722069e-15,0],[3,0.004462069723208538,0.4381802273458216,-0.0019434620153348766,0.8988739629404916],[1,0.5572016837940187,51.97620557313351,0.02386521946895269]],[12,"Bip001 L Forearm",18,[-28],[0,"503RTkgyFOwZRj7QxbXFGT",null,null,null,1,0],[1,0.263291478157043,0,0],[3,-2.7197715504795845e-20,-3.0893820368327117e-17,-0.0008803606294924629,0.9999996124825059],[1,-6.233264281423144e-18,-3.5401778996822195e-15,-0.10088191006996569]],[3,"Bip001 L Hand",19,[[5,"sword01",-29,[0,"98Mxm4C+NAIp1/ms1CXDWg",null,null,null,1,0],[1,0.0919111594557762,0.0340489186346531,-0.14926840364933],[3,0.6409670678902519,-0.3070256396863465,-0.5278458569202463,-0.4650540030872693],[1,-112.37885078724646,75.2002383569922,5.587571211625747]]],[0,"7cWlWOkFtKX6ILXuZfhYqO",null,null,null,1,0],[1,0.199572831392288,-5.9604643443123e-10,1.42108543975646e-16],[3,-0.7068252124052271,1.0458620867947887e-8,1.0614867442646885e-8,0.7073882378922519],[1,-89.95437890588059,0.0000017075473071153707,1.3340228971442967e-8]],[12,"Bip001 R Clavicle",4,[-30],[0,"9fRB6KFOpAz6pb5W8NAqZg",null,null,null,1,0],[1,0,0.0000436370064562652,-0.0232834853231907],[3,-0.6087613827171046,0.00024128768333211222,0.793353275899464,0.0003167210153793466],[1,-179.95597003338875,104.99999512047448,0.011961643569376679]],[12,"Bip001 R UpperArm",21,[-31],[0,"a72KzY4dJDrb/Ifgjl7CSF",null,null,null,1,0],[1,0.272405058145523,6.82120985672115e-14,-1.42108543975646e-16],[3,-0.030114175418424236,-0.43755956999841955,0.05059855375302801,0.897259463867486],[1,-0.5631334715243025,-51.96038786477057,6.727854372934277]],[12,"Bip001 R Forearm",22,[-32],[0,"5eAc4VAlRExZ6nABKN5Ihq",null,null,null,1,0],[1,0.263291418552399,0,-7.62939436071974e-8],[3,-8.302567498559346e-18,-5.588016764292516e-17,-0.13176086831298384,0.9912815309393233],[1,-1.8510999406615195e-15,-6.705762043264369e-15,-15.14271605062808]],[3,"Bip001 R Hand",23,[[5,"shield01",-33,[0,"4f4kzbhYBIMIVjz0nZTcvw",null,null,null,1,0],[1,0.124533005058765,-0.00692871073260903,0.0576667860150337],[3,0.5417342069004817,-0.1379658103002438,0.11668003843623054,0.8208990515846776],[1,67.2841187503732,-20.685866498064005,2.411917394086867]]],[0,"19JEI2tAtAo5mcAZ7XSRWH",null,null,null,1,0],[1,0.199572905898094,8.88178399847791e-18,0],[3,0.7068252124052272,-1.9327187937127104e-17,1.9311804031753923e-17,0.707388237892252],[1,89.95437890588059,-3.1308585900006548e-15,-7.956237644289779e-23]],[3,"Bip001 Head",4,[[23,"Bip001 HeadNub",-34,[0,"ebvw49UjBMKoIvQOBhsyUF",null,null,null,1,0],[1,0.475234657526016,-1.45519149031062e-13,2.99510855318999e-20]]],[0,"4ckJuubwNG3KpsMgkuxo12",null,null,null,1,0],[1,0.0547203049063683,-1.38777874976217e-19,2.71050537062924e-22],[3,-7.265599787883251e-14,1.1042733174299354e-9,-0.0003988305609355657,0.9999999204670887],[1,4.214242912539149e-11,1.2654042790710837e-7,-0.04570261697650697]],[8,"shield",2,[[9,-35,[4,"ffoVYmt2NOmIBz5DHpacF8"],[3],[2],1,4,5]],[0,"2fgzyRcBxNmZKzBdJpnT0Q",null,null,null,1,0],[3,0.9999999999999878,0,0,-1.569582366300871e-7],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998201391097,0,0]],[8,"sword",2,[[9,-36,[4,"9aCVBuMeZPv6so1VxT6c40"],[6],[2],1,7,8]],[0,"d0xEUY/HZBVZJ0EMEz3doQ",null,null,null,1,0],[3,0.9999999999999878,0,0,-1.569582366300871e-7],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998201391097,0,0]],[36,"shield01",2,[[9,-37,[4,"ca1srfPsJJgKKJww9GO/JE"],[9],[2],1,10,11]],[0,"464KPea2NOibwROP5moUvA",null,null,null,1,0],[1,-0.00499999988824129,0,0.00499999988824129],[3,0.9999999999999878,0,0,-1.569582366300871e-7],[1,87.7489852905273,87.7489852905273,87.7489852905273],[1,-179.99998201391097,0,0]]],0,[0,5,1,0,1,1,0,-1,2,0,-1,6,0,-2,5,0,-3,26,0,-4,27,0,-5,28,0,-1,8,0,-2,12,0,-3,16,0,-1,17,0,-2,21,0,-3,25,0,0,5,0,-2,7,0,1,6,0,-1,9,0,-1,10,0,-1,11,0,0,11,0,-1,13,0,-1,14,0,-1,15,0,0,15,0,-1,18,0,-1,19,0,-1,20,0,0,20,0,-1,22,0,-1,23,0,-1,24,0,0,24,0,0,25,0,1,26,0,1,27,0,1,28,0,8,1,3,0,7,4,0,16,37],[0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,2,3,-1,2,3,-1,2,3,-1,2,3,-1,4],[4,15,16,4,17,18,4,19,20,21,22,23,6,6]],[[[16,".bin",4069446529,[{"primitives":[{"primitiveMode":7,"jointMapIndex":0,"vertexBundelIndices":[0],"indexView":{"offset":70128,"length":6960,"count":3480,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":70128,"count":974,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}],"jointMaps":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]]},"minPosition",8,[1,-0.006235902663320303,-0.022199034690856934,-0.00308204535394907],"maxPosition",8,[1,0.006235902663320303,0.0000021968080545775592,0.0029080540407449007]]],-1],0,0,[],[],[]],[[[15,"Skin-0",2507836796,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh","RootNode/Bip001/Bip001 Pelvis","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf","RootNode/Bip001","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 R Thigh/Bip001 R Calf/Bip001 R Foot","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head/Bip001 HeadNub","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 Head","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 L Thigh/Bip001 L Calf/Bip001 L Foot","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand","RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[[[7,13.330132484436035,0.5659459233283997,-86.72872161865234,0,86.68508911132812,2.7542707920074463,13.341398239135742,0,2.808293342590332,-87.70392608642578,-0.14067713916301727,0,0.719279408454895,0.022746119648218155,0.1780078411102295,1],[7,-13.330143928527832,-0.5657054781913757,-86.72872924804688,0,86.68508911132812,2.7542707920074463,-13.34140396118164,0,2.8082568645477295,-87.70392608642578,0.14043928682804108,0,0.7192792892456055,0.022746119648218155,-0.17800788581371307,1],[7,0.00012169029650976881,0.0002419860102236271,87.74899291992188,0,-87.74898529052734,-0.00001708502350084018,0.00012169034744147211,0,0.000017085358194890432,-87.74899291992188,0.0002419859665678814,0,-0.738336980342865,6.5663993339959426e-12,0.0000010239258472211077,1],[7,9.57883514729474e-8,-0.00012308494478929788,87.74899291992188,0,-87.74895477294922,0.06985900551080704,1.9377911542051152e-7,0,-0.06985900551080704,-87.74896240234375,-0.00012308482837397605,0,-0.8148396015167236,0.0007684377487748861,2.1313388831600832e-9,1],[7,-13.329378128051758,-0.5835267305374146,-86.72872924804688,0,86.68132781982422,2.870192527770996,-13.341405868530273,0,2.9255402088165283,-87.7000961303711,0.14043459296226501,0,0.3512277603149414,0.023215843364596367,-0.17800790071487427,1],[7,0.00012029569188598543,87.74899291992188,-5.373075573876507e-15,0,-0.000017085358194890432,2.3417063427233487e-11,-87.74898529052734,0,-87.74899291992188,0.00012029569188598543,0.000017085358194890432,0,3.742711869592075e-12,-5.034101432245029e-17,-0.738336980342865,1],[7,13.329362869262695,0.5837728977203369,-86.72872161865234,0,86.68132781982422,2.870190143585205,13.341397285461426,0,2.9255752563476562,-87.7000961303711,-0.14067858457565308,0,0.3512278199195862,0.023215826600790024,0.1780078411102295,1],[7,0.000003835630195681006,0.00012029569188598543,-87.74899291992188,0,87.74898529052734,-0.000017085363651858643,0.0000038356070035661105,0,-0.000017085358194890432,-87.74899291992188,-0.00012029569188598543,0,0.08038292825222015,0.021714111790060997,-0.16770152747631073,1],[7,0.0001178546590381302,-0.00012308491568546742,87.74899291992188,0,-87.74898529052734,-0.000017085523722926155,0.00011785465176217258,0,0.000017085358194890432,-87.74899291992188,-0.00012308494478929788,0,-1.6451982259750366,5.87142210406455e-7,0.0000022096469365351368,1],[7,0.0001178546590381302,-0.00012308491568546742,87.74899291992188,0,-87.74898529052734,-0.000017085523722926155,0.00011785465176217258,0,0.000017085358194890432,-87.74899291992188,-0.00012308494478929788,0,-1.1699634790420532,-5.1139195988980646e-8,0.0000015713648053861107,1],[7,-84.7590103149414,-0.00011930296022910625,22.711111068725586,0,22.711111068725586,0.000016954663806245662,84.7590103149414,0,-0.00011962600547121838,87.74899291992188,0.00001450093350285897,0,0.26615607738494873,4.7347434417588374e-8,1.0832682847976685,1],[7,84.7590103149414,-0.00012128843081882223,22.711111068725586,0,22.711111068725586,0.000016954663806245662,-84.7590103149414,0,0.00011276743316557258,87.74899291992188,0.00004776870264322497,0,0.26615607738494873,4.734742375944734e-8,-1.0832682847976685,1],[7,9.57883514729474e-8,-0.00012308494478929788,87.74899291992188,0,-87.74895477294922,0.06985900551080704,1.9377911542051152e-7,0,-0.06985900551080704,-87.74896240234375,-0.00012308482837397605,0,-0.9650411605834961,0.0008880393579602242,2.4630661954461175e-9,1],[7,9.57883514729474e-8,-0.00012308494478929788,87.74899291992188,0,-87.74895477294922,0.06985900551080704,1.9377911542051152e-7,0,-0.06985900551080704,-87.74896240234375,-0.00012308482837397605,0,-1.1152427196502686,0.0009316118084825575,2.583918634613269e-9,1],[7,0.000003835630195681006,0.00012029569188598543,-87.74899291992188,0,87.74898529052734,-0.000017085363651858643,0.0000038356070035661105,0,-0.000017085358194890432,-87.74899291992188,-0.00012029569188598543,0,0.08038290590047836,0.0217141043394804,0.16770148277282715,1],[7,34.319801330566406,0.7709546685218811,80.75544738769531,0,80.75911712646484,-0.3673746883869171,-34.31785202026367,0,0.0365816168487072,87.74483489990234,-0.853227436542511,0,0.8495007157325745,-0.006890855263918638,-0.672168493270874,1],[7,-34.105628967285156,3.229346752166748,80.7852783203125,0,80.19358825683594,-9.797160148620605,34.247459411621094,0,10.280043601989746,87.1405258178711,0.8565954566001892,0,0.8434666395187378,-0.10610441118478775,0.6714277267456055,1],[7,34.318382263183594,0.8313809037208557,80.75544738769531,0,80.75962829589844,-0.22517983615398407,-34.317848205566406,0,-0.11791250109672546,87.7447509765625,-0.8532273173332214,0,0.5862204432487488,-0.005858692806214094,-0.6721684336662292,1],[7,34.318382263183594,-80.75476837158203,0.8956841230392456,0,80.75962829589844,34.31765365600586,-0.25250619649887085,0,-0.11791250109672546,0.9230960011482239,87.74404907226562,0,0.38664767146110535,0.6721636056900024,-0.0063939220272004604,1],[7,-33.76499557495117,-5.791998386383057,80.7852783203125,0,79.96836853027344,11.491525650024414,34.24745178222656,0,-12.840116500854492,86.80025482177734,0.8565958738327026,0,0.5877475142478943,0.04913555085659027,0.6714276671409607,1],[7,-33.76499557495117,80.7806396484375,5.856326103210449,0,79.96836853027344,34.256595611572266,-11.464248657226562,0,-12.840116500854492,0.9257150888442993,-86.7995376586914,0,0.3881746232509613,0.671466588973999,-0.04860087111592293,1],[7,-26.09381103515625,47.70235824584961,-68.8729248046875,0,72.14217376708984,-23.88349151611328,-43.87446212768555,0,-42.596981048583984,-69.67027282714844,-32.11593246459961,0,0.23747046291828156,0.08072908967733383,-0.6914553046226501,1]],8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8]]],0,0,[],[],[]],[[[16,".bin",2470630447,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":648,"length":48,"count":24,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":648,"count":9,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.009095229208469391,-0.00829001609236002,-0.0038153051864355803],"maxPosition",8,[1,-0.002438712865114212,-0.0038237078115344048,0.0021244001109153032]]],-1],0,0,[],[],[]],[[[16,".bin",1932649666,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":2016,"length":264,"count":132,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":2016,"count":28,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,0.004531483631581068,-0.006827499717473984,-0.009057947434484959],"maxPosition",8,[1,0.00610683299601078,-0.003189224749803543,0.0015691547887399793]]],-1],0,0,[],[],[]],[[[15,"Skin-2",1928083474,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 L Clavicle/Bip001 L UpperArm/Bip001 L Forearm/Bip001 L Hand/sword01"],[[[7,-0.000007191588792920811,-0.00005849258377566002,-87.7490005493164,0,24.115726470947266,-84.3700942993164,0.0000542638408660423,0,-84.37010192871094,-24.115724563598633,0.000022989974240772426,0,-0.00041664036689326167,-0.5413689017295837,0.47052377462387085,1]],8]]],0,0,[],[],[]],[[[15,"Skin-3",3487038830,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[[[7,-26.09381103515625,47.70235824584961,-68.8729248046875,0,72.14216613769531,-23.883501052856445,-43.87446594238281,0,-42.59699249267578,-69.6702651977539,-32.11592483520508,0,0.24138452112674713,0.08198083937168121,-0.6857008934020996,1]],8]]],0,0,[],[],[]],[[[16,".bin",3939686354,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6480,"length":480,"count":240,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":6480,"count":90,"stride":72},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_joints","format":42,"isNormalized":false},{"name":"a_weights","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-0.009095229208469391,-0.00861329771578312,-0.0038153051864355803],"maxPosition",8,[1,-0.0022758706472814083,-0.0038237078115344048,0.002340445527806878]]],-1],0,0,[],[],[]],[[[15,"Skin-1",1546018204,["RootNode/Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/shield01"],[[[7,-26.09381103515625,47.70235824584961,-68.8729248046875,0,72.14216613769531,-23.883501052856445,-43.87446594238281,0,-42.59699249267578,-69.6702651977539,-32.11592483520508,0,0.23747046291828156,0.08072908967733383,-0.6914553046226501,1]],8]]],0,0,[],[],[]],[[[54,[[55,"ShadowFlow",[[56,"ShadowStage"]]],[57,"ForwardFlow",1,[[58,"ForwardStage",[[59,["default"]],[60,true,1,["default"]]]]]]]]],0,0,[],[],[]]]]
